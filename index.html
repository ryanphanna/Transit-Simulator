<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Transit Simulator ‚Äî Baseline</title>
  <link rel="preconnect" href="https://unpkg.com">
  <style>
    :root{
      --topbar-h: 64px;
      --bezel-x: clamp(16px, 4vw, 56px);
      --col-gap: 24px;
      --left-w: 360px;
      --right-w: 360px;
      --card-bg: rgba(255,255,255,0.85);
      --card-br: 14px;
      --grid-border: #d9efe4;
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #eef8f3, #f4fbf7);
      color:#0f172a;
    }
    #topbar{
      min-height: var(--topbar-h);
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:center;
      padding: 0 var(--bezel-x);
      gap:12px;
      border-bottom:1px solid #e8f3ee;
      background: #f7fcfa;
      position: sticky; top:0; z-index: 10;
    }
    #topbarLeft{align-items:center; gap:12px; justify-self:start;}
    #topbarCenter{display:flex; justify-content:center; align-items:center; text-align:center; justify-self:center;}
    #topbarRight{display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:flex-end; justify-self:end;}
    @media (max-width: 768px){
      #topbar{grid-template-columns: 1fr; justify-items:center;}
      #topbarLeft,#topbarRight{justify-content:center; text-align:center;}
      #topbarCenter{order:-1;}
    }
    .app-title{font-size:20px; color:#0f172a; letter-spacing:0.02em;}
    .btn{height:32px; padding:0 10px; border:1px solid #cae9df; border-radius:10px; background:#fff; cursor:pointer;}
    .btn.active{background:#d1fae5; border-color:#34d399;}
    #viewport{height: calc(100vh - var(--topbar-h)); padding: 16px var(--bezel-x); overflow: hidden;}
    .grid3{display:grid; height:100%; gap: var(--col-gap); grid-template-columns: 1fr;}
    @media (min-width: 1024px){.grid3{grid-template-columns: var(--left-w) minmax(560px, 1fr) var(--right-w);}}
    .card{background: var(--card-bg); border: 1px solid #dff1ea; border-radius: var(--card-br); box-shadow: 0 2px 6px rgba(20,83,45,0.06);}
    .col{min-height:0; height:100%;}
    .col-scroll{overflow: auto;}
    .col-center{overflow: hidden; display:flex;}
    .center-card{display:flex; flex-direction:column; width:100%;}
    .center-head,.center-foot{padding:12px 14px; border-bottom:1px solid #e9f4ef;}
    .center-head{display:flex; flex-direction:column; gap:4px;}
    .center-foot{border-top:1px solid #e9f4ef; border-bottom:0;}
    .map-wrap{flex:1; display:grid; place-items:center; overflow:hidden;}
    #mapSquare{background:#f6fbf9; border:1px solid #e3f2ec; border-radius:12px; position:relative;}
    .gridLines{position:absolute; inset:0; background-image:linear-gradient(to right, var(--grid-border) 1px, transparent 1px),linear-gradient(to bottom, var(--grid-border) 1px, transparent 1px); background-size: 32px 32px; border-radius:12px; pointer-events:none; z-index:1;}
    .routeOverlay{position:absolute; inset:0; pointer-events:none; z-index:2;}
    .routeOverlay svg{width:100%; height:100%; overflow:visible;}
    .tile{position:absolute; transform: translate(-50%,-50%); font-size:18px;}
    .section{padding:14px; border-bottom:1px solid #e9f4ef;}
    .section:last-child{border-bottom:0;}
    .hstack{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .stat{font-weight:700; color:#059669; font-size:28px;}
    .muted{color:#64748b; font-size:13px;}
    .tag{ padding:2px 6px; border-radius:9999px; font-size:11px; background:#eef2ff; color:#4338ca; }
    .status-bar{
      text-align:center;
      font-size: 0.98rem;
      color:#475569;
      margin: 4px 0 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    @media (max-width: 720px){
      .status-bar{ white-space: normal; line-height: 1.35; }
    }
    .demandHeat { position:absolute; inset:0; pointer-events:none; z-index:3; }
    .heatDot { position:absolute; width:10px; height:10px; border-radius:50%; background:rgba(239,68,68,0.22); transform:translate(-50%,-50%); filter:blur(4px); }
    .odLine { position:absolute; inset:0; pointer-events:none; z-index:5; }
    .odLine svg { overflow:visible; }
    .badge { display:inline-block; padding:2px 8px; border-radius:9999px; background:#fee2e2; color:#991b1b; font-size:12px; font-weight:600; }
    .routeItem { background:rgba(255,255,255,0.9); border:1px solid #d7ece3; border-radius:10px; padding:10px; margin-top:8px; cursor:pointer; transition:box-shadow 0.2s, border-color 0.2s; }
    .routeItem.active { border-color:#34d399; box-shadow:0 0 0 2px rgba(52,211,153,0.25); }
    .routeItem .routeTitle { display:flex; align-items:center; justify-content:space-between; font-weight:600; color:#0f172a; }
    .routeItem input[type="color"] { border:none; background:transparent; width:36px; height:24px; cursor:pointer; }
    .routeItem input[type="text"] { flex:1; min-width:120px; border:1px solid #d1e7dc; border-radius:6px; padding:4px 6px; font-size:13px; font-weight:600; color:#0f172a; background:#f9fffc; }
    .routeItem .routeMeta { display:flex; align-items:center; gap:10px; margin-top:8px; font-size:13px; color:#475569; flex-wrap:wrap; }
    .routeItem label { display:flex; align-items:center; gap:4px; font-size:12px; color:#475569; }
    .stopMarker { position:absolute; width:18px; height:18px; border-radius:50%; transform:translate(-50%,-50%); border:2px solid #ecfdf5; box-shadow:0 0 0 2px rgba(13,148,136,0.15); pointer-events:none; display:flex; align-items:center; justify-content:center; background:#059669; z-index:4; }
    .stopMarker .stopCore { width:6px; height:6px; border-radius:50%; background:#ecfdf5; box-shadow:0 0 3px rgba(15,23,42,0.25) inset; flex-shrink:0; }
    .coach{ background:#ecfdf5; color:#065f46; border:1px solid #a7f3d0; border-radius:10px; padding:8px 12px; font-size:13px; }
    .halo{ position:absolute; border-radius:50%; border:1px dashed rgba(16,185,129,.55); background:rgba(16,185,129,.10); pointer-events:none; transform:translate(-50%,-50%); }
    .mapTip{ position:absolute; z-index:25; padding:6px 8px; background:#111827; color:#fff; border-radius:8px; font-size:12px; pointer-events:none; transform:translate(-50%,-100%); white-space:nowrap; display:none; }
    .modalMask{ position:fixed; inset:0; background:rgba(2,6,23,.45); display:none; place-items:center; z-index:50; }
    .modal{ background:#fff; width:min(680px,calc(100vw - 32px)); border-radius:14px; box-shadow:0 10px 30px rgba(2,6,23,.25); padding:18px; }
    .modal h3{ margin:4px 0 8px; }
  </style>
</head>
<body>
  <header id="topbar">
    <div class="hstack" id="topbarLeft">
      <button class="btn" id="play">‚ñ∂ Play</button>
      <button class="btn spd" data-x="1">1√ó</button>
      <button class="btn spd" data-x="4">4√ó</button>
      <button class="btn spd" data-x="10">10√ó</button>
    </div>
    <div id="topbarCenter">
      <strong class="app-title">Transit Simulator</strong>
    </div>
    <div class="hstack" id="topbarRight">
      <button class="btn" id="jump">‚è≠ Jump</button>
      <button class="btn" id="settings">‚öô Settings</button>
      <button class="btn" id="helpBtn">‚ùî Help</button>
      <button class="btn" id="reset">‚ü≤ Reset</button>
      <button class="btn" id="newmap">üó∫Ô∏è New Map</button>
    </div>
  </header>

  <main id="viewport">
    <div class="grid3">
      <aside class="col col-scroll card" id="leftCol">
        <div class="section"><div class="muted">Cash</div><div class="stat" id="cash">$5,000,000</div></div>
        <div class="section">
          <div class="muted">Riders / hr</div>
          <div style="display:flex; gap:10px; align-items:baseline;">
            <div><strong id="liveRidersHr">0</strong> <span class="tag" id="liveStatusTag">paused</span></div>
            <div class="muted">| projected: <span id="projRidersHr">0</span></div>
          </div>
          <div id="liveReason" class="muted" style="font-size:12px; margin-top:4px;"></div>
        </div>
        <div class="section"><div class="muted">Vehicles in use</div><div id="veh">0 / 10 (Spare: 10)</div></div>
        <div class="section"><div class="muted">Daily money</div><div id="money">$0 ‚Äì $0 = $0</div></div>
        <div class="section">
          <div class="muted">Potential trips / day</div>
          <div id="potentialTrips">‚Äî</div>
        </div>
      </aside>

      <section class="col col-center card" id="centerCol">
        <div class="center-card">
          <div class="center-head">
            <!-- inside the center header above the map -->
            <div id="coach" class="coach" role="status" aria-live="polite">
              Click the map to create your first route. Add stops where <b>homes üè†</b> and <b>destinations</b> overlap.
            </div>
            <div id="statusBar" class="status-bar" aria-live="polite"></div>
          </div>
          <div class="map-wrap"><div id="mapSquare"><div class="gridLines"></div></div></div>
          <div class="center-foot muted">Select a route to begin placing stops. Shift-click tiles to remove stops from the active route.</div>
        </div>
      </section>

      <aside class="col col-scroll card" id="rightCol">
        <div class="section" id="routesPanel">
          <div class="hstack" style="justify-content:space-between;">
            <strong>Routes</strong>
            <button class="btn" id="addRoute">Ôºã Route (N)</button>
          </div>
          <div id="routeList" class="muted" style="margin-top:8px;">No routes yet. Add one to begin planning.</div>
          <div id="routeDetails" class="muted" style="margin-top:12px;">
            Select a route to edit its color, vehicles, and stops.
          </div>
        </div>
        <div class="section"><strong>Fare &amp; Policy</strong><div class="hstack"><button class="btn" id="fareMinus">‚Äì</button><div id="fare">$2.00</div><button class="btn" id="farePlus">+</button></div><div class="muted">Range: $1.50 ‚Äì $3.00</div></div>
        <div class="section"><strong>Service Hours</strong><div class="muted">Start 06:00 ¬∑ End 22:00</div></div>
        <div class="section">
          <strong>Demand</strong>
          <div class="hstack" style="margin-top:6px;">
            <label class="hstack">
              <input id="toggleDemandHeat" type="checkbox" />
              <span class="muted">Show demand heat</span>
            </label>
            <label class="hstack">
              <input id="toggleInspector" type="checkbox" />
              <span class="muted">Demand inspector</span>
            </label>
          </div>
          <div class="muted" id="demandSummary" style="margin-top:6px;">Potential trips/day: ‚Äî</div>
        </div>
      </aside>
    </div>
  </main>

  <div id="helpMask" class="modalMask">
    <div class="modal">
      <h3>How to Play (Quick)</h3>
      <ol>
        <li><b>Click the map</b> to create a route and place a stop.</li>
        <li>Add stops so <b>homes üè†</b> and <b>destinations</b> (üõçÔ∏è üè´ üè¢ üçî üé° üè•) are both within ~1 tile of some stop on the same route.</li>
        <li>Keep the loop <b>short</b>; assign more vehicles to improve headway if crowded.</li>
        <li>Riders/hr ‚âà min(<i>demand/hr</i>, <i>capacity/hr</i>) √ó <i>price factor</i>.</li>
      </ol>
      <p style="font-size:12px;color:#64748b">Tips: Press <b>N</b> for a new route, <b>H</b> for help, <b>Esc</b> to stop editing a route.</p>
      <div style="text-align:right; margin-top:10px;">
        <button class="btn" id="closeHelp">Close</button>
      </div>
    </div>
  </div>

  <script>
  const $ = s=>document.querySelector(s), $$ = s=>[...document.querySelectorAll(s)];
  const rand=n=>Math.floor(Math.random()*n);

  // --- CONFIG (tweak later)
  const GRID=20;          // tiles per side
  const HOMES=60;         // number of homes emoji
  const POIS=24;          // number of POIs emoji
  const POI_TYPES=['üõçÔ∏è','üè´','üé°','üè•','üè¢','üçî'];
  const ATTR = {         // attractiveness by type (rough)
    'üõçÔ∏è':1.2,'üè´':1.0,'üé°':0.8,'üè•':0.6,'üè¢':0.9,'üçî':0.7
  };
  const DIST_DECAY=0.06;  // higher ‚Üí fewer long trips
  const TRIPS_PER_HOME=8; // target avg daily trips per home (both ways counted as 2)
  const MAX_VEHICLES=10;  // garage capacity
  const KM_PER_TILE=0.4;  // rough size of one tile in km
  const AVG_SPEED_KPH=22; // average operating speed
  const DWELL_PER_STOP_MIN=0.5; // dwell time per stop in minutes
  const TARGET_HEADWAY_MIN=10;  // target headway passengers expect
  const MIN_LOOP_MINUTES=5;     // minimum practical loop cycle
  const MINUTES_PER_DAY=24*60;
  const SERVICE_START=6*60;
  const SERVICE_END=22*60;
  const VEHICLE_COST_PER_HOUR=95;
  const BASE_CASH=5_000_000;
  const FARE_MIN=1.5;
  const FARE_MAX=3.0;
  const FARE_STEP=0.05;
  const DEFAULT_FARE=2.0;
  const DEFAULT_STOP_COLOR="#059669";

  let simMinute=SERVICE_START;
  let simDay=1;
  let simRunning=false;
  let simTimer=null;
  let simSpeed=1;
  let cash=BASE_CASH;
  let fare=DEFAULT_FARE;
  let ridersToday=0;
  let revenueToday=0;
  let expensesToday=0;
  let lastRidershipHr=0;
  let lastVehiclesUsed=0;

  window.TS = window.TS || {};
  if(window.TS.cityName === undefined) window.TS.cityName = "Tutorial City";
  if(window.TS.population === undefined) window.TS.population = 100000;
  if(window.TS.goalPct === undefined) window.TS.goalPct = 5;
  if(window.TS.goalDays === undefined) window.TS.goalDays = 30;

  // --- MAP SIZING (square fits viewport)
  function sizeMap(){
    const map=$("#mapSquare"),wrap=$("#centerCol .map-wrap");
    const avail=Math.min(wrap.clientWidth,wrap.clientHeight);
    const cell=Math.max(16, Math.floor(avail/GRID)), size=cell*GRID;
    map.style.width=size+"px"; map.style.height=size+"px";
    map.querySelector(".gridLines").style.backgroundSize=cell+"px "+cell+"px";
    map.dataset.cell=cell;
    ensureMapOverlays();
    repositionStops();
    renderRouteOverlays();
  }

  function ensureMapOverlays(){
    const map=$("#mapSquare");
    if(!haloLayer){
      haloLayer=document.createElement("div");
      haloLayer.style.position="absolute";
      haloLayer.style.inset="0";
      haloLayer.style.pointerEvents="none";
      haloLayer.style.zIndex="2";
      map.appendChild(haloLayer);
    }
    if(!tipEl){ tipEl=document.createElement("div"); tipEl.className="mapTip"; map.appendChild(tipEl); }
  }

  // --- STATE
  let homes=[], pois=[];
  let od=[]; // list of {ox,oy,dx,dy,tripsPerDay,type,dist}
  let inspectorOn=false, heatOn=false;
  let stops=new Map(); // key "x,y" -> {id,x,y,el,usage}
  let routes=[]; // list of {id,name,color,vehicles,stops:[],ridership}
  let editingRouteId=null;
  let routeSeq=1;
  let routeOverlayLayer=null;
  let haloLayer=null, tipEl=null;

  // --- helpers
  function addTile(emoji,gx,gy,scale=1){
    const map=$("#mapSquare");
    const d=document.createElement("div");
    d.className="tile";
    d.dataset.gx=gx; d.dataset.gy=gy; d.dataset.scale=scale;
    d.textContent=emoji;
    map.appendChild(d);
    return d;
  }

  function layoutTiles(){
    const map=$("#mapSquare");
    const cell=parseInt(map.dataset.cell||"24",10);
    const tiles=$$("#mapSquare .tile");
    const base = Math.max(12, Math.round(cell*0.55));
    for(const el of tiles){
      const gx=+el.dataset.gx, gy=+el.dataset.gy, sc=+(el.dataset.scale||1);
      el.style.left = (gx*cell + cell/2) + "px";
      el.style.top  = (gy*cell + cell/2) + "px";
      el.style.fontSize = Math.round(base*sc) + "px";
    }
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  function stopKey(gx,gy){ return `${gx},${gy}`; }

  function clamp(min,max,value){
    return Math.min(max, Math.max(min, value));
  }

  function cellSize(){ return parseInt($("#mapSquare").dataset.cell||"24",10); }
  function tileCenter(gx,gy){ const c=cellSize(); return {x:gx*c+c/2,y:gy*c+c/2}; }

  function clearHalos(){ if(haloLayer) haloLayer.innerHTML=""; }
  function drawCatchmentsForRoute(route){
    ensureMapOverlays(); clearHalos();
    if(!route) return;
    const c=cellSize(), r=(1+0.5)*c*2; // catchment radius ~1 tile
    const seen=new Set();
    for(const sid of route.stops){
      const s=stopIdToCoords(sid); if(!s) continue;
      const k=s.x+","+s.y; if(seen.has(k)) continue; seen.add(k);
      const p=tileCenter(s.x,s.y);
      const d=document.createElement("div");
      d.className="halo";
      d.style.width=r+"px"; d.style.height=r+"px";
      d.style.left=p.x+"px"; d.style.top=p.y+"px";
      haloLayer.appendChild(d);
    }
  }

  function computeServedTripsForTemp(route, gx, gy){
    const key=stopKey(gx,gy);
    const existed=stops.has(key);
    const temp = { ...route, stops:[...route.stops] };
    const stop=ensureStop(gx,gy); // ensures marker but we‚Äôll revert usage
    const id=stop.id;
    if(!temp.stops.includes(id)) temp.stops.push(id);
    updateRouteMetrics(temp);
    if(!existed){
      removeStopMarkerIfUnused(stop);
    }
    // revert temp marker usage so we don't leak markers
    stop.usage=(stop.usage||0);
    return temp.servedTripsPerDay||0;
  }

  function stopIdToCoords(stopId){
    if(!stopId) return null;
    const key=stopId.startsWith('s') ? stopId.slice(1) : stopId;
    const stop=stops.get(key);
    if(!stop) return null;
    return {x:stop.x, y:stop.y};
  }

  function routeStopCoords(route){
    if(!route) return [];
    const coords=[];
    const seen=new Set();
    for(const stopId of route.stops){
      if(seen.has(stopId)) continue;
      const c=stopIdToCoords(stopId);
      if(c){ coords.push(c); seen.add(stopId); }
    }
    return coords;
  }

  function ensureRouteOverlay(){
    const map=$("#mapSquare");
    if(!map) return null;
    if(!routeOverlayLayer || routeOverlayLayer.parentNode!==map){
      routeOverlayLayer=document.createElement("div");
      routeOverlayLayer.className="routeOverlay";
      map.appendChild(routeOverlayLayer);
    }
    return routeOverlayLayer;
  }

  function renderRouteOverlays(){
    const map=$("#mapSquare");
    if(!map) return;
    const layer=ensureRouteOverlay();
    if(!layer) return;
    const cell=parseInt(map.dataset.cell||"24",10);
    const size=cell*GRID;
    layer.innerHTML="";
    const svg=document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute("viewBox",`0 0 ${size} ${size}`);
    svg.setAttribute("width", size);
    svg.setAttribute("height", size);
    layer.appendChild(svg);
    const strokeWidth=Math.max(2, Math.round(cell*0.12));
    for(const route of routes){
      const coords=routeStopCoords(route);
      if(coords.length<2) continue;
      const points=coords.map(c=>`${c.x*cell+cell/2},${c.y*cell+cell/2}`).join(" ");
      const polyline=document.createElementNS("http://www.w3.org/2000/svg","polyline");
      polyline.setAttribute("points", points);
      polyline.setAttribute("fill", "none");
      polyline.setAttribute("stroke", route.color || DEFAULT_STOP_COLOR);
      polyline.setAttribute("stroke-width", strokeWidth);
      polyline.setAttribute("stroke-linecap", "round");
      polyline.setAttribute("stroke-linejoin", "round");
      svg.appendChild(polyline);
    }
  }

  function computeLoopMinutes(route){
    const coords=routeStopCoords(route);
    if(coords.length<2){
      return Math.max(MIN_LOOP_MINUTES, coords.length * DWELL_PER_STOP_MIN || MIN_LOOP_MINUTES);
    }
    let tileDistance=0;
    for(let i=0;i<coords.length;i++){
      const a=coords[i];
      const b=coords[(i+1)%coords.length];
      tileDistance+=Math.hypot(a.x-b.x, a.y-b.y);
    }
    const travelKm=tileDistance*KM_PER_TILE;
    const travelMinutes=(travelKm/AVG_SPEED_KPH)*60;
    const dwellMinutes=coords.length*DWELL_PER_STOP_MIN;
    return Math.max(MIN_LOOP_MINUTES, travelMinutes+dwellMinutes);
  }

  function escapeHTML(str){
    return (str??'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]||c));
  }

  function ensureStop(gx,gy){
    const key=stopKey(gx,gy);
    const map=$("#mapSquare");
    const cell=parseInt(map.dataset.cell||"24",10);
    if(stops.has(key)){
      const existing=stops.get(key);
      if(!existing.routes) existing.routes=new Set();
      const size=Math.max(14, Math.round(cell*0.45));
      existing.el.style.width=size+"px";
      existing.el.style.height=size+"px";
      let core=existing.el.querySelector('.stopCore');
      if(!core){
        core=document.createElement("div");
        core.className="stopCore";
        existing.el.appendChild(core);
      }
      if(core){
        const coreSize=Math.max(4, Math.round(size*0.35));
        core.style.width=coreSize+"px";
        core.style.height=coreSize+"px";
      }
      updateStopColors(existing);
      return existing;
    }
    const marker=document.createElement("div");
    marker.className="stopMarker";
    const size=Math.max(14, Math.round(cell*0.45));
    marker.style.width=size+"px";
    marker.style.height=size+"px";
    marker.style.left=(gx*cell+cell/2)+"px";
    marker.style.top =(gy*cell+cell/2)+"px";
    const core=document.createElement("div");
    core.className="stopCore";
    const coreSize=Math.max(4, Math.round(size*0.35));
    core.style.width=coreSize+"px";
    core.style.height=coreSize+"px";
    marker.appendChild(core);
    map.appendChild(marker);
    const stop={id:`s${key}`,x:gx,y:gy,el:marker,usage:0,routes:new Set()};
    stops.set(key,stop);
    updateStopColors(stop);
    return stop;
  }

  function removeStopMarkerIfUnused(stop){
    if(stop.usage<=0){
      if(stop.el && stop.el.parentNode) stop.el.parentNode.removeChild(stop.el);
      if(stop.routes) stop.routes.clear();
      stops.delete(stopKey(stop.x,stop.y));
    }
  }

  function resetAllStops(){
    stops.forEach(s=>{ if(s.el && s.el.parentNode) s.el.parentNode.removeChild(s.el); });
    stops.clear();
    renderRouteOverlays();
  }

  function repositionStops(){
    const cell=parseInt($("#mapSquare").dataset.cell||"24",10);
    stops.forEach(stop=>{
      stop.el.style.left=(stop.x*cell+cell/2)+"px";
      stop.el.style.top =(stop.y*cell+cell/2)+"px";
      const size=Math.max(14, Math.round(cell*0.45));
      stop.el.style.width=size+"px";
      stop.el.style.height=size+"px";
      const core=stop.el.querySelector('.stopCore');
      if(core){
        const coreSize=Math.max(4, Math.round(size*0.35));
        core.style.width=coreSize+"px";
        core.style.height=coreSize+"px";
      }
      updateStopColors(stop);
    });
  }

  function updateStopColors(stop){
    if(!stop || !stop.el) return;
    if(!stop.routes) stop.routes=new Set();
    const colors=[];
    const validIds=new Set();
    for(const route of routes){
      if(stop.routes.has(route.id)){
        colors.push(route.color || DEFAULT_STOP_COLOR);
        validIds.add(route.id);
      }
    }
    for(const id of [...stop.routes]){
      if(!validIds.has(id)){
        stop.routes.delete(id);
      }
    }
    let background=DEFAULT_STOP_COLOR;
    if(colors.length===1){
      background=colors[0];
    }else if(colors.length>1){
      let angle=0;
      const total=colors.length;
      const segments=colors.map((color,index)=>{
        const start=angle;
        const span=index===total-1 ? 360-start : 360/total;
        angle+=span;
        const end=start+span;
        return `${color} ${start}deg ${end}deg`;
      });
      background=`conic-gradient(${segments.join(',')})`;
    }
    stop.el.style.background=background;
    const core=stop.el.querySelector('.stopCore');
    if(core){
      core.style.background='#ecfdf5';
    }
  }

  function refreshStopsForRoute(route){
    if(!route) return;
    for(const stopId of route.stops){
      const key=stopId.startsWith('s') ? stopId.slice(1) : stopId;
      const stop=stops.get(key);
      if(stop){
        if(!stop.routes) stop.routes=new Set();
        stop.routes.add(route.id);
        updateStopColors(stop);
      }
    }
  }

  function resetRoutes(){
    routes.length=0;
    editingRouteId=null;
    routeSeq=1;
    resetAllStops();
    renderRoutesPanel();
    clearHalos();
    if(tipEl) tipEl.style.display="none";
    updateRouteStats();
    updateRouteDetails();
    updateEditingStatus();
  }

  function makeRoute(){
    const id=`r${routeSeq++}`;
    const colors=['#1d4ed8','#dc2626','#047857','#9333ea','#f59e0b','#0891b2'];
    const color=colors[(routes.length)%colors.length];
    const route={id,name:`Route ${routes.length+1}`,color,vehicles:1,stops:[],ridership:0,loopMinutes:MIN_LOOP_MINUTES,headway:Infinity,servedTripsPerDay:0};
    routes.push(route);
    selectRoute(id);
    renderRoutesPanel();
    updateRouteStats();
    return route;
  }

  function selectRoute(id){
    editingRouteId=id;
    if(inspectorLayer) inspectorLayer.innerHTML="";
    renderRoutesPanel();
    updateRouteDetails();
    updateEditingStatus();
    const route=routes.find(r=>r.id===id);
    drawCatchmentsForRoute(route);
    updateRiderNumbersUI(route||null);
    if(tipEl) tipEl.style.display="none";
  }

  function routeStopCount(route){
    return route ? route.stops.length : 0;
  }

  function updateRiderNumbersUI(route){
    const activeRoute = route || routes.find(r=>r.id===editingRouteId) || null;
    const serviceHours = Math.max(1, (SERVICE_END-SERVICE_START)/60);
    const served = activeRoute?.servedTripsPerDay || 0;
    const demandHr = Math.round(served / serviceHours);
    const veh = Math.max(0, Number(activeRoute?.vehicles)||0);
    const loopMinutes = activeRoute?.loopMinutes;
    const vehPerHr = (loopMinutes && veh>0) ? (veh / (loopMinutes/60)) : 0;
    const capHr = Math.round(vehPerHr * 45);
    const priceFactor = Math.max(0.5, Math.min(1.5, 1 - 0.10*((fare-2.0)/0.5)));
    const projected = Math.floor(Math.min(demandHr, capHr) * priceFactor);

    const live = Math.round(window.TS?.liveRidersPerHour || 0);

    const liveEl = document.getElementById('liveRidersHr');
    const projEl = document.getElementById('projRidersHr');
    const projInline = document.getElementById('projRidersHrInline');
    if(liveEl) liveEl.textContent = live.toString();
    if(projEl) projEl.textContent = projected.toString();
    if(projInline) projInline.textContent = projected.toString();

    const tag = document.getElementById('liveStatusTag');
    if(tag){
      const paused = !!window.TS?.paused;
      tag.textContent = paused ? 'paused' : 'live';
      tag.style.background = paused ? '#fee2e2' : '#dcfce7';
      tag.style.color = paused ? '#991b1b' : '#166534';
    }

    const reason = document.getElementById('liveReason');
    if(!reason) return;

    if(!activeRoute){
      reason.textContent = '';
      return;
    }

    let msgs = [];
    if(window.TS?.paused) msgs.push('Simulation is paused ‚Äî press ‚ñ∂Ô∏é Play.');
    const clockMins = window.TS?.clockMins ?? 0;
    const inService = clockMins >= SERVICE_START && clockMins < SERVICE_END;
    if(!inService) msgs.push('Outside service hours.');
    if(veh <= 0) msgs.push('No vehicles assigned to this route.');
    if((activeRoute.stops?.length||0) < 2) msgs.push('Add at least two stops.');
    if(served <= 0) msgs.push('This route doesn‚Äôt cover both ends (home + destination) of any trips yet.');
    if(msgs.length === 0 && live === 0 && projected > 0){
      msgs.push('No one has boarded yet ‚Äî give it a minute for the first bus to reach stops.');
    }

    reason.textContent = (live===0) ? ('Why 0 right now: ' + msgs.join(' ')) : '';
  }

  function updateRouteMetrics(route){
    const coords=routeStopCoords(route);
    const loopMinutes=computeLoopMinutes(route);
    const vehicles=Math.max(0, Number(route.vehicles)||0);
    const headway=vehicles>0 ? loopMinutes/vehicles : Infinity;
    route.loopMinutes=loopMinutes;
    route.headway=headway;

    if(coords.length<2){
      route.ridership=0;
      route.servedTripsPerDay=0;
      return;
    }

    const coverageRadius=1.01;
    let servedTrips=0;
    for(const trip of od){
      const originServed=coords.some(c=>Math.hypot(c.x-trip.ox, c.y-trip.oy)<=coverageRadius);
      if(!originServed) continue;
      const destServed=coords.some(c=>Math.hypot(c.x-trip.dx, c.y-trip.dy)<=coverageRadius);
      if(!destServed) continue;
      servedTrips+=trip.tripsPerDay;
    }

    route.servedTripsPerDay=servedTrips;

    const serviceHours=Math.max(1, (SERVICE_END-SERVICE_START)/60);
    const hourlyDemand=servedTrips/serviceHours;
    if(!servedTrips || !isFinite(headway) || vehicles<=0){
      route.ridership=0;
      return;
    }

    const effectiveHeadway=Math.max(headway, 0.1);
    const waitFactor=clamp(0,1, TARGET_HEADWAY_MIN/effectiveHeadway);
    route.ridership=Math.round(hourlyDemand*waitFactor);
  }

  function updateRouteStats(){
    let vehiclesUsed=0, ridershipHr=0;
    for(const route of routes){
      updateRouteMetrics(route);
      if(route.id===editingRouteId) updateRouteBreakdownUI(route);
      vehiclesUsed+=route.vehicles;
      ridershipHr+=route.ridership;
    }
    lastVehiclesUsed=vehiclesUsed;
    lastRidershipHr=ridershipHr;
    window.TS = window.TS || {};
    window.TS.liveRidersPerHour = ridershipHr;
    const spare=Math.max(0, MAX_VEHICLES-vehiclesUsed);
    const vehLabel=$("#veh");
    if(vehLabel){ vehLabel.textContent=`${vehiclesUsed} / ${MAX_VEHICLES} (Spare: ${spare})`; }
    const active=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(active||null);
  }

  function updateRouteBreakdownUI(route){
    if(!route) return;
    const serviceHours = Math.max(1, (SERVICE_END-SERVICE_START)/60);
    const served = route.servedTripsPerDay||0;
    const demandHr = Math.round(served/serviceHours);
    const veh = Math.max(0, Number(route.vehicles)||0);
    const vehPerHr = veh>0 ? (veh / (route.loopMinutes/60)) : 0;
    const capHr = Math.round(vehPerHr * 45); // simple capacity
    const fareNow = fare;
    const priceFactor = Math.max(0.5, Math.min(1.5, 1 - 0.10*((fareNow-2.0)/0.5)));
    const projected = Math.floor(Math.min(demandHr, capHr) * priceFactor);

    const container=document.getElementById("routeDetails");
    if(!container) return;
    const box = document.getElementById("routeBreakdown") || (() => {
      const el=document.createElement("div");
      el.id="routeBreakdown"; el.className="muted"; el.style.marginTop="8px";
      container.appendChild(el);
      return el;
    })();

    box.innerHTML = `
      <div><strong>Projected riders/hr = <span id="projRidersHrInline">${projected.toString()}</span></strong></div>
      <div>Served trips/day (both ends covered): <b>${served.toLocaleString()}</b></div>
      <div>Demand/hr = served √∑ ${serviceHours} = <b>${demandHr}</b></div>
      <div>Capacity/hr = (vehicles/loop hr) √ó 45 = <b>${vehPerHr.toFixed(1)}</b>√ó45 = <b>${capHr}</b></div>
      <div>Price factor (@ $${fareNow.toFixed(2)}): <b>${priceFactor.toFixed(2)}</b></div>
      <div>Riders/hr ‚âà min(demand, capacity) √ó price = <b>${Math.min(demandHr, capHr)}</b> √ó ${priceFactor.toFixed(2)}</div>
    `;
  }

  function updateRouteDetails(){
    const details=$("#routeDetails");
    if(!details) return;
    const route=routes.find(r=>r.id===editingRouteId);
    if(!route){
      details.innerHTML='Select a route to edit its color, vehicles, and stops.';
      const breakdown=document.getElementById("routeBreakdown");
      if(breakdown) breakdown.remove();
      return;
    }
    const uniqueStops=new Set(route.stops).size;
    const safeName=escapeHTML(route.name||'');
    const loopLabel = route.loopMinutes ? route.loopMinutes.toFixed(1) : '‚Äî';
    const headwayLabel = (route.vehicles>0 && isFinite(route.headway)) ? `${route.headway.toFixed(1)} min` : 'No service';
    details.innerHTML=`<div><strong>${safeName}</strong></div>
      <div>Stops placed: ${route.stops.length} (${uniqueStops} unique)</div>
      <div>Vehicles assigned: ${route.vehicles}</div>
      <div>Loop time: ${loopLabel} min ¬∑ Headway: ${headwayLabel}</div>
      <div>Estimated riders / hr (frequency-adjusted): ${route.ridership.toLocaleString()}</div>
      <div style="margin-top:6px;">Click the map to add stops. Shift-click to remove the stop for this tile.</div>`;
    updateRouteBreakdownUI(route);
  }

  function updateEditingStatus(){
    const foot=$(".center-foot");
    if(!foot) return;
    const route=routes.find(r=>r.id===editingRouteId);
    if(route){
      foot.textContent=`Editing ${route.name}: click the map to add stops ¬∑ Shift-click to remove.`;
    }else if(inspectorOn){
      foot.textContent='Demand inspector active: click a home to view its top destinations.';
    }else{
      foot.textContent='Select a route to begin placing stops. Shift-click tiles to remove stops from the active route.';
    }
  }

  function renderRoutesPanel(){
    const list=$("#routeList");
    if(!list) return;
    list.innerHTML="";
    if(!routes.length){
      list.textContent='No routes yet. Add one to begin planning.';
      list.classList.add('muted');
      renderRouteOverlays();
      return;
    }
    list.classList.remove('muted');
    for(const route of routes){
      const item=document.createElement("div");
      item.className="routeItem"+(route.id===editingRouteId?" active":"");
      item.dataset.route=route.id;
      item.style.borderLeft=`6px solid ${route.color}`;
      item.style.paddingLeft="12px";

      const title=document.createElement("div");
      title.className="routeTitle";

      const nameInput=document.createElement("input");
      nameInput.type="text";
      nameInput.value=route.name;
      nameInput.addEventListener("click",e=>e.stopPropagation());
      nameInput.addEventListener("input",e=>{ route.name=e.target.value; updateRouteDetails(); updateEditingStatus(); });
      nameInput.addEventListener("blur",()=>{
        if(!route.name || !route.name.trim()){
          const fallbackIndex=routes.indexOf(route)+1;
          route.name=`Route ${fallbackIndex}`;
          nameInput.value=route.name;
          updateRouteDetails();
          updateEditingStatus();
        }
      });

      const colorInput=document.createElement("input");
      colorInput.type="color";
      colorInput.value=route.color;
      colorInput.addEventListener("click",e=>e.stopPropagation());
      colorInput.addEventListener("input",e=>{
        route.color=e.target.value;
        updateRouteDetails();
        refreshStopsForRoute(route);
        renderRouteOverlays();
        renderRoutesPanel();
      });

      title.appendChild(nameInput);
      title.appendChild(colorInput);
      item.appendChild(title);

      const meta=document.createElement("div");
      meta.className="routeMeta";

      const stopsSpan=document.createElement("span");
      stopsSpan.textContent=`Stops: ${routeStopCount(route)}`;

      const ridersSpan=document.createElement("span");
      ridersSpan.textContent=`Riders/hr*: ${route.ridership.toLocaleString()}`;
      ridersSpan.title='Ridership scales with headway ‚Äî assign more vehicles for higher frequency.';

      const headwaySpan=document.createElement("span");
      headwaySpan.textContent=route.vehicles>0 && isFinite(route.headway)
        ? `Headway: ${route.headway.toFixed(1)} min`
        : 'Headway: No service';

      const vehiclesLabel=document.createElement("label");
      vehiclesLabel.textContent="Vehicles";
      const vehiclesInput=document.createElement("input");
      vehiclesInput.type="number";
      vehiclesInput.min="0";
      vehiclesInput.max=String(MAX_VEHICLES);
      vehiclesInput.value=route.vehicles;
      vehiclesInput.style.width="56px";
      vehiclesInput.addEventListener("click",e=>e.stopPropagation());
      vehiclesInput.addEventListener("change",e=>{
        const v=Math.max(0, Math.min(MAX_VEHICLES, parseInt(e.target.value||"0",10)));
        route.vehicles=v;
        vehiclesInput.value=v;
        updateRouteStats();
        updateRouteDetails();
        renderRoutesPanel();
      });
      vehiclesLabel.appendChild(vehiclesInput);

      meta.appendChild(stopsSpan);
      meta.appendChild(ridersSpan);
      meta.appendChild(headwaySpan);
      meta.appendChild(vehiclesLabel);
      item.appendChild(meta);

      item.addEventListener("click",()=>{ selectRoute(route.id); });

      list.appendChild(item);
    }
    renderRouteOverlays();
  }

  function addStopToRoute(route,gx,gy){
    const stop=ensureStop(gx,gy);
    if(route.stops.includes(stop.id)){
      return;
    }
    route.stops.push(stop.id);
    stop.usage=(stop.usage||0)+1;
    if(!stop.routes) stop.routes=new Set();
    stop.routes.add(route.id);
    updateStopColors(stop);
    updateRouteMetrics(route);
    updateRouteStats();
    updateRouteDetails();
    renderRoutesPanel();
    renderRouteOverlays();
    drawCatchmentsForRoute(route);
  }

  function removeStopFromRoute(route,gx,gy){
    const key=stopKey(gx,gy);
    const stop=stops.get(key);
    if(!stop) return;
    const idx=route.stops.lastIndexOf(stop.id);
    if(idx>-1){
      route.stops.splice(idx,1);
      stop.usage=Math.max(0,(stop.usage||0)-1);
      if(stop.routes) stop.routes.delete(route.id);
      updateStopColors(stop);
      removeStopMarkerIfUnused(stop);
      updateRouteMetrics(route);
      updateRouteStats();
      updateRouteDetails();
      renderRoutesPanel();
      renderRouteOverlays();
      drawCatchmentsForRoute(route);
    }
  }

  function mapClickRouter(e){
    const map=$("#mapSquare");
    if(!map) return;
    const rect=map.getBoundingClientRect();
    const c=cellSize();
    const gx=Math.max(0, Math.min(GRID-1, Math.floor((e.clientX-rect.left)/c)));
    const gy=Math.max(0, Math.min(GRID-1, Math.floor((e.clientY-rect.top )/c)));

    if(inspectorOn && !editingRouteId){
      handleInspectorClick(e);
      return;
    }

    // If a route is selected -> edit that route (add/remove with Shift)
    const active=routes.find(r=>r.id===editingRouteId);

    // If no routes or none selected, first click creates a route and places the first stop
    if(!active){
      const r = makeRoute();              // creates, selects, renders
      addStopToRoute(r, gx, gy);          // first stop
      $("#coach") && ($("#coach").textContent="Great! Keep adding stops where homes üè† and destinations overlap. Press ‚ñ∂Ô∏é Play to start service.");
      drawCatchmentsForRoute(r);
      return;
    }

    if(e.shiftKey){ removeStopFromRoute(active, gx, gy); }
    else{ addStopToRoute(active, gx, gy); }
    drawCatchmentsForRoute(active);
  }

  // --- city generation: homes + destinations
  function generateCityState(){
    homes=[]; pois=[];
    for(let i=0;i<HOMES;i++){
      const gx=Math.min(GRID-1, Math.max(0, rand(GRID) + (rand(3)-1)));
      const gy=Math.min(GRID-1, Math.max(0, rand(GRID) + (rand(3)-1)));
      homes.push({x:gx,y:gy,scale:1+Math.random()*0.3});
    }
    for(let i=0;i<POIS;i++){
      const t=POI_TYPES[rand(POI_TYPES.length)];
      const gx=rand(GRID), gy=rand(GRID);
      pois.push({x:gx,y:gy,type:t,attr:ATTR[t]||1,scale:1.1});
    }
  }

  function renderCityDOM(){
    const map=$("#mapSquare");
    [...map.querySelectorAll(".tile")].forEach(n=>n.remove());
    for(const h of homes){ h.el = addTile('üè†', h.x, h.y, h.scale); }
    for(const p of pois){ p.el = addTile(p.type, p.x, p.y, p.scale); }
    layoutTiles();
  }

  // --- OD generation: for each home, allocate daily trips to top-K nearby POIs by gravity model
  function buildOD(){
    od.length=0;
    let total=0;
    for(const h of homes){
      // score each POI by attractiveness * f(distance)
      const scored=pois.map(p=>{
        const d=dist(h,p);
        const w=p.attr * Math.exp(-DIST_DECAY*d);
        return {p,w,d};
      }).filter(r=>r.w>0.01).sort((a,b)=>b.w-a.w);

      // take top 6 targets, normalize to daily trips
      const top=scored.slice(0,6);
      const sumW=top.reduce((s,r)=>s+r.w,0)||1;
      for(const r of top){
        const share=r.w/sumW;
        const trips=Math.max(0, Math.round(TRIPS_PER_HOME*share));
        if(trips>0){
          od.push({ox:h.x,oy:h.y,dx:r.p.x,dy:r.p.y,tripsPerDay:trips,type:r.p.type,dist:r.d});
          total+=trips;
        }
      }
    }
    $("#demandSummary").textContent=`Potential trips/day: ${total.toLocaleString()}`;
    $("#potentialTrips") && ($("#potentialTrips").textContent = total.toLocaleString());
    updateRouteStats();
    renderRoutesPanel();
    updateRouteDetails();
  }

  // --- Demand Heat overlay
  function renderHeat(){
    const map=$("#mapSquare");
    let layer=map.querySelector(".demandHeat");
    if(!layer){ layer=document.createElement("div"); layer.className="demandHeat"; map.appendChild(layer); }
    layer.innerHTML="";
    if(!heatOn) return;
    const cell=parseInt(map.dataset.cell||"24",10);
    // intensity per origin
    const byOrigin = new Map();
    for(const t of od){
      const key=t.ox+","+t.oy;
      byOrigin.set(key,(byOrigin.get(key)||0)+t.tripsPerDay);
    }
    // scale dots
    const vals=[...byOrigin.values()];
    const max=Math.max(1, ...vals);
    for(const [key,v] of byOrigin.entries()){
      const [gx,gy]=key.split(",").map(Number);
      const dot=document.createElement("div");
      dot.className="heatDot";
      dot.style.left=(gx*cell+cell/2)+"px";
      dot.style.top =(gy*cell+cell/2)+"px";
      const alpha = 0.18 + 0.30*(v/max);
      dot.style.background=`rgba(239,68,68,${alpha.toFixed(2)})`;
      dot.style.width = (10 + 14*(v/max))+"px";
      dot.style.height= (10 + 14*(v/max))+"px";
      layer.appendChild(dot);
    }
  }

  // --- Demand Inspector: click a üè† to draw its OD lines to top destinations
  let inspectorLayer;
  function enableInspectorHandlers(){
    const map=$("#mapSquare");
    if(!inspectorLayer){
      inspectorLayer=document.createElement("div");
      inspectorLayer.className="odLine";
      map.appendChild(inspectorLayer);
    }
    updateEditingStatus();
  }
  function disableInspectorHandlers(){
    if(inspectorLayer) inspectorLayer.innerHTML="";
    updateEditingStatus();
  }
  function handleInspectorClick(e){
    // only react if clicked near a home
    const cell=parseInt($("#mapSquare").dataset.cell||"24",10);
    const rect=$("#mapSquare").getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const gx=Math.floor(mx/cell), gy=Math.floor(my/cell);
    // find nearest home within 1 cell
    let nearest=null, best=1e9;
    for(const h of homes){
      const d=Math.hypot(h.x-gx, h.y-gy);
      if(d<best){best=d; nearest=h;}
    }
    if(!nearest || best>1.1){ // not a home
      if(inspectorLayer) inspectorLayer.innerHTML="";
      return;
    }
    // draw lines for this home
    const list=od.filter(t=>t.ox===nearest.x && t.oy===nearest.y).sort((a,b)=>b.tripsPerDay-a.tripsPerDay).slice(0,6);
    drawODLines(list);
  }
  function drawODLines(list){
    if(!inspectorLayer) return;
    inspectorLayer.innerHTML="";
    const cell=parseInt($("#mapSquare").dataset.cell||"24",10);
    for(const t of list){
      const x1=t.ox*cell+cell/2, y1=t.oy*cell+cell/2;
      const x2=t.dx*cell+cell/2, y2=t.dy*cell+cell/2;
      const w = Math.max(1, Math.round(1 + t.tripsPerDay/6));
      const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
      svg.setAttribute("style","position:absolute; left:0; top:0; width:100%; height:100%;");
      const path = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      // Route orthogonally to better match the grid aesthetic
      const viaX = Math.abs(x2 - x1) > Math.abs(y2 - y1) ? x2 : x1;
      const viaY = viaX === x2 ? y1 : y2;
      const points = `${x1},${y1} ${viaX},${viaY} ${x2},${y2}`;
      path.setAttribute("points", points);
      path.setAttribute("fill", "none");
      path.setAttribute("stroke","rgba(220,38,38,0.6)");
      path.setAttribute("stroke-width",w);
      path.setAttribute("stroke-linecap","round");
      path.setAttribute("stroke-linejoin","round");
      svg.appendChild(path);
      inspectorLayer.appendChild(svg);
    }
  }

  // --- init & resize
  function rebuildAll(){
    sizeMap();
    generateCityState();
    renderCityDOM();
    buildOD();
    renderHeat();
  }

  function formatMoney(value){
    const sign=value<0?"-":"";
    const abs=Math.abs(value);
    return `${sign}$${abs.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2})}`;
  }

  function updateFinanceUI(){
    const cashEl=$("#cash");
    if(cashEl){ cashEl.textContent=formatMoney(cash); }
    const money=$("#money");
    if(money){
      const net=revenueToday-expensesToday;
      money.textContent=`${formatMoney(revenueToday)} ‚Äì ${formatMoney(expensesToday)} = ${formatMoney(net)}`;
    }
  }

  function formatTime(minute){
    const h=Math.floor(minute/60)%24;
    const m=minute%60;
    return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}`;
  }

  function serviceStatus(){
    let base;
    if(simMinute < SERVICE_START) base="Before service";
    else if(simMinute >= SERVICE_END) base="After service";
    else base="In service";
    if(!simRunning && simMinute>=SERVICE_START && simMinute<SERVICE_END) base+=" (paused)";
    return base;
  }

  function updateStatusBar(){
    const dayText = (window.TS?.dayText) || `Day ${simDay}`;
    const timeText = (window.TS?.timeText) || formatTime(simMinute);
    const serviceText = (window.TS?.serviceText) || serviceStatus();

    const cityName = (window.TS?.cityName) || "Tutorial City";
    const population = (window.TS?.population ?? 100000);
    const goalPct = (window.TS?.goalPct ?? 5);
    const goalDays = (window.TS?.goalDays ?? 30);

    const left = `${dayText} ¬∑ ${timeText} ‚Äî ${serviceText}`;
    const right = `${cityName} ¬∑ Population ${Number(population).toLocaleString()} ¬∑ Goal: ${goalPct}% for ${goalDays} days`;

    const full = `${left} ¬∑ ${right}`;
    const el = document.getElementById("statusBar");
    if(el){
      el.textContent = full;
      el.title = full;
    }
  }

  function updateClockLabel(){
    window.TS = window.TS || {};
    window.TS.dayText = `Day ${simDay}`;
    window.TS.timeText = formatTime(simMinute);
    window.TS.serviceText = serviceStatus();
    window.TS.clockMins = simMinute;
    updateStatusBar();
  }

  function resetDailyTallies(){
    ridersToday=0;
    revenueToday=0;
    expensesToday=0;
    updateFinanceUI();
  }

  function updatePlayButton(){
    const btn=$("#play");
    if(btn){ btn.textContent=simRunning?"‚è∏ Pause":"‚ñ∂ Play"; }
  }

  function updateSpeedButtons(){
    $$(".spd").forEach(btn=>{
      const mult=parseInt(btn.dataset.x||"1",10);
      if(mult===simSpeed) btn.classList.add("active");
      else btn.classList.remove("active");
    });
  }

  function stopSimTimer(){
    if(simTimer){ clearInterval(simTimer); simTimer=null; }
  }

  function setSimRunning(next){
    if(simRunning===next) return;
    simRunning=next;
    window.TS = window.TS || {};
    window.TS.paused = !simRunning;
    updatePlayButton();
    updateClockLabel();
    if(simRunning){
      stopSimTimer();
      simTimer=setInterval(()=>advanceSim(simSpeed), 400);
    }else{
      stopSimTimer();
    }
    const route=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(route||null);
  }

  function setSpeed(mult){
    simSpeed=mult;
    updateSpeedButtons();
  }

  function stepMinute(){
    const inService = simMinute>=SERVICE_START && simMinute<SERVICE_END;
    const ridersPerMinute = inService ? lastRidershipHr/60 : 0;
    const revenue = ridersPerMinute * fare;
    const expenses = inService ? (lastVehiclesUsed * VEHICLE_COST_PER_HOUR)/60 : 0;
    ridersToday += ridersPerMinute;
    revenueToday = Math.round((revenueToday + revenue)*100)/100;
    expensesToday = Math.round((expensesToday + expenses)*100)/100;
    cash = Math.round((cash + revenue - expenses)*100)/100;

    simMinute++;
    if(simMinute>=MINUTES_PER_DAY){
      simMinute=0;
      simDay++;
      resetDailyTallies();
    }
  }

  function advanceSim(minutes){
    for(let i=0;i<minutes;i++){
      stepMinute();
    }
    updateClockLabel();
    updateFinanceUI();
    const route=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(route||null);
  }

  function resetSimulationState(){
    stopSimTimer();
    simRunning=false;
    simDay=1;
    simMinute=SERVICE_START;
    cash=BASE_CASH;
    fare=DEFAULT_FARE;
    simSpeed=1;
    lastRidershipHr=0;
    lastVehiclesUsed=0;
    window.TS = window.TS || {};
    window.TS.paused = true;
    window.TS.liveRidersPerHour = 0;
    resetDailyTallies();
    updateFareDisplay();
    updatePlayButton();
    updateSpeedButtons();
    updateClockLabel();
    const route=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(route||null);
  }

  function jumpToServiceStart(){
    setSimRunning(false);
    if(simMinute >= SERVICE_START){
      simDay++;
      resetDailyTallies();
    }
    simMinute=SERVICE_START;
    updateClockLabel();
    updateFinanceUI();
    const route=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(route||null);
  }

  function updateFareDisplay(){
    const fareLabel=$("#fare");
    if(fareLabel){ fareLabel.textContent=`$${fare.toFixed(2)}`; }
  }

  function setFare(value){
    const clamped=Math.min(FARE_MAX, Math.max(FARE_MIN, Math.round(value*100)/100));
    fare=clamped;
    updateFareDisplay();
    const r=editingRouteId ? routes.find(x=>x.id===editingRouteId) : null;
    if(r){
      updateRouteBreakdownUI(r);
      updateRiderNumbersUI(r);
    }else{
      updateRiderNumbersUI(null);
    }
  }

  function init(){
    rebuildAll();
    resetSimulationState();
    const coachEl=$("#coach");
    const helpMask=$("#helpMask");
    const helpBtn=$("#helpBtn");
    const closeHelp=$("#closeHelp");
    const mapEl=$("#mapSquare");
    const addRouteBtn=$("#addRoute");

    coachEl && (coachEl.textContent = "Click the map to create your first route. Aim for tiles where homes üè† and destinations overlap.");

    if(helpBtn && helpMask){ helpBtn.onclick=()=>{ helpMask.style.display="grid"; }; }
    if(closeHelp && helpMask){ closeHelp.onclick=()=>{ helpMask.style.display="none"; }; }

    // controls
    $("#fareMinus").onclick=()=>{ setFare(fare-FARE_STEP); };
    $("#farePlus").onclick=()=>{ setFare(fare+FARE_STEP); };
    window.addEventListener("resize",()=>{
      sizeMap();
      layoutTiles();
      drawCatchmentsForRoute(routes.find(r=>r.id===editingRouteId));
      renderHeat();
      if(inspectorOn){
        if(inspectorLayer) inspectorLayer.innerHTML="";
      }
    });

    if(mapEl){
      mapEl.addEventListener("click", mapClickRouter);
      mapEl.addEventListener("mousemove",(e)=>{
        if(!editingRouteId) return;
        const r=routes.find(x=>x.id===editingRouteId); if(!r) return;
        ensureMapOverlays();
        const rect=mapEl.getBoundingClientRect(), c=cellSize();
        const gx=Math.max(0, Math.min(GRID-1, Math.floor((e.clientX-rect.left)/c)));
        const gy=Math.max(0, Math.min(GRID-1, Math.floor((e.clientY-rect.top )/c)));
        const base = r.servedTripsPerDay||0;
        const withStop = computeServedTripsForTemp(r, gx, gy);
        const delta = Math.max(0, withStop - base);
        const pos = tileCenter(gx,gy);
        if(!tipEl) return;
        tipEl.style.left=pos.x+"px";
        tipEl.style.top =pos.y+"px";
        tipEl.textContent = delta>0 ? `Add stop: +${delta} trips/day` : `Add stop`;
        tipEl.style.display="block";
      });
      mapEl.addEventListener("mouseleave",()=>{ tipEl && (tipEl.style.display="none"); });
    }
    if(addRouteBtn){
      addRouteBtn.addEventListener("click", ()=>{
        const route=makeRoute();
        updateEditingStatus();
        drawCatchmentsForRoute(route);
        coachEl && (coachEl.textContent="Click the map to add stops on your new route.");
      });
    }

    // Demand toggles
    $("#toggleDemandHeat").addEventListener("change",(e)=>{ heatOn=e.target.checked; renderHeat(); });
    $("#toggleInspector").addEventListener("change",(e)=>{ inspectorOn=e.target.checked; if(inspectorOn) enableInspectorHandlers(); else disableInspectorHandlers(); });

    // speed controls
    $$(".spd").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const mult=parseInt(btn.dataset.x||"1",10);
        setSpeed(mult);
      });
    });

    $("#play").addEventListener("click", ()=>{ setSimRunning(!simRunning); });
    $("#jump").addEventListener("click", ()=>{ jumpToServiceStart(); });
    $("#newmap").addEventListener("click", ()=>{ setSimRunning(false); resetRoutes(); rebuildAll(); resetSimulationState(); updateStatusBar(); coachEl && (coachEl.textContent = "Click the map to create your first route. Aim for tiles where homes üè† and destinations overlap."); helpMask && (helpMask.style.display="none"); });
    $("#reset").addEventListener("click", ()=>{ setSimRunning(false); resetRoutes(); rebuildAll(); resetSimulationState(); updateStatusBar(); coachEl && (coachEl.textContent = "Click the map to create your first route. Aim for tiles where homes üè† and destinations overlap."); helpMask && (helpMask.style.display="none"); });

    window.addEventListener("keydown",(e)=>{
      const activeEl=document.activeElement;
      if(activeEl && (activeEl.tagName==='INPUT' || activeEl.tagName==='TEXTAREA' || activeEl.isContentEditable)) return;
      if(e.ctrlKey || e.metaKey || e.altKey) return;
      if(e.key.toLowerCase()==="n"){ makeRoute(); coachEl && (coachEl.textContent="Click the map to add stops on your new route."); }
      else if(e.key.toLowerCase()==="h"){ helpMask && (helpMask.style.display="grid"); }
      else if(e.key==="Escape"){ editingRouteId=null; renderRoutesPanel(); updateRouteDetails(); updateEditingStatus(); clearHalos(); updateRiderNumbersUI(null); tipEl && (tipEl.style.display="none"); }
    });

    updateStatusBar();
  }

  window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
