<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Transit Simulator ‚Äî Baseline</title>
  <link rel="preconnect" href="https://unpkg.com">
  <style>
    :root{
      --topbar-h: 64px;
      --bezel-x: clamp(8px, 2vw, 24px);
      --col-gap: 16px;
      --left-w: 360px;
      --right-w: 250px;
      --card-bg: rgba(255,255,255,0.85);
      --card-br: 14px;
      --grid-border: #d9efe4;
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #eef8f3, #f4fbf7);
      color:#0f172a;
    }
    #topbar{
      min-height: var(--topbar-h);
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:center;
      padding: 0 var(--bezel-x);
      gap:12px;
      border-bottom:1px solid #e8f3ee;
      background: #f7fcfa;
      position: sticky; top:0; z-index: 10;
    }
    #topbarLeft{align-items:center; gap:12px; justify-self:start;}
    #topbarCenter{display:flex; justify-content:center; align-items:center; text-align:center; justify-self:center;}
    #topbarRight{display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:flex-end; justify-self:end;}
    @media (max-width: 768px){
      #topbar{grid-template-columns: 1fr; justify-items:center;}
      #topbarLeft,#topbarRight{justify-content:center; text-align:center;}
      #topbarCenter{order:-1;}
    }
    .app-title{font-size:20px; color:#0f172a; letter-spacing:0.02em;}
    .btn{height:32px; padding:0 10px; border:1px solid #cae9df; border-radius:10px; background:#fff; cursor:pointer;}
    .btn.active{background:#d1fae5; border-color:#34d399;}
    #viewport{height: calc(100vh - var(--topbar-h)); padding: 8px var(--bezel-x); overflow: hidden;}
    .grid3{display:grid; height:100%; gap: var(--col-gap); grid-template-columns: 1fr;}
    @media (min-width: 1024px){.grid3{grid-template-columns: minmax(700px, 1fr) 250px;}}
    .card{background: var(--card-bg); border: 1px solid #dff1ea; border-radius: var(--card-br); box-shadow: 0 2px 6px rgba(20,83,45,0.06);}
    .col{min-height:0; height:100%;}
    .col-scroll{overflow: auto;}
    .col-center{overflow: hidden; display:flex;}
    .center-card{display:flex; flex-direction:column; width:100%; position:relative;}
    .center-head,.center-foot{padding:12px 14px; border-bottom:1px solid #e9f4ef;}
    .center-head{display:flex; flex-direction:column; gap:4px;}
    .center-foot{border-top:1px solid #e9f4ef; border-bottom:0;}
    .map-wrap{flex:1; display:grid; place-items:center; overflow:hidden;}
    #mapSquare{background:#f6fbf9; border:1px solid #e3f2ec; border-radius:12px; position:relative;}
    .gridLines{position:absolute; inset:0; background-image:linear-gradient(to right, var(--grid-border) 1px, transparent 1px),linear-gradient(to bottom, var(--grid-border) 1px, transparent 1px); background-size: 32px 32px; border-radius:12px; pointer-events:none; z-index:1;}
    .routeOverlay{position:absolute; inset:0; pointer-events:none; z-index:2;}
    .routeOverlay svg{width:100%; height:100%; overflow:visible;}
    .tile{position:absolute; transform: translate(-50%,-50%); font-size:18px;}
    .section{padding:14px; border-bottom:1px solid #e9f4ef;}
    .section:last-child{border-bottom:0;}
    .hstack{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .stat{font-weight:700; color:#059669; font-size:28px;}
    .muted{color:#64748b; font-size:13px;}
    .tag{ padding:2px 6px; border-radius:9999px; font-size:11px; background:#eef2ff; color:#4338ca; }
    .status-bar{
      text-align:center;
      font-size: 0.98rem;
      color:#475569;
      margin: 4px 0 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    @media (max-width: 720px){
      .status-bar{ white-space: normal; line-height: 1.35; }
    }
    .demandHeat { position:absolute; inset:0; pointer-events:none; z-index:3; }
    .heatDot { position:absolute; width:10px; height:10px; border-radius:50%; background:rgba(239,68,68,0.22); transform:translate(-50%,-50%); filter:blur(4px); }
    .odLine { position:absolute; inset:0; pointer-events:none; z-index:5; }
    .odLine svg { overflow:visible; }
    .badge { display:inline-block; padding:2px 8px; border-radius:9999px; background:#fee2e2; color:#991b1b; font-size:12px; font-weight:600; }
    .status-chip{display:inline-flex; align-items:center; gap:8px; border-radius:9999px; padding:4px 10px; font-size:12px; font-weight:600; background:#f1f5f9; color:#0f172a; margin-top:8px;}
    .status-chip[data-state="ok"]{background:#dcfce7; color:#166534;}
    .status-chip[data-state="warn"]{background:#fee2e2; color:#991b1b;}
    .status-chip button{pointer-events:auto;}
    .chip-actions{display:flex; align-items:center; gap:6px;}
    .chip-tip{font-weight:500; font-size:11px; color:#475569;}
    .chip-secondary{font-weight:400;}
    .chip-actions .btn{height:26px; padding:0 8px; font-size:12px;}
    .chip-actions .btn.secondary{background:#fff7ed; border-color:#fb923c; color:#c2410c;}
    #bannerHost{position:fixed; top:calc(var(--topbar-h) + 8px); left:50%; transform:translateX(-50%); z-index:30; display:flex; flex-direction:column; gap:8px; align-items:center; pointer-events:none;}
    .banner{pointer-events:auto; background:#0f172a; color:#f8fafc; padding:10px 16px; border-radius:12px; box-shadow:0 10px 30px rgba(15,23,42,0.25); display:flex; flex-wrap:wrap; align-items:center; gap:12px; font-size:13px;}
    .banner[data-state="warn"]{background:#991b1b;}
    .banner button{height:28px; padding:0 12px; border-radius:9999px; border:none; background:#f8fafc; color:#0f172a; cursor:pointer; font-weight:600;}
    .banner button.secondary{background:rgba(248,250,252,0.15); color:#f8fafc; border:1px solid rgba(248,250,252,0.25);}
    .banner.fade{opacity:0; transition:opacity 0.3s ease;}
    #toastHost{position:fixed; bottom:24px; left:50%; transform:translateX(-50%); z-index:40; display:flex; flex-direction:column; gap:8px; align-items:center; pointer-events:none;}
    .toast{pointer-events:auto; background:#111827; color:#f8fafc; padding:10px 16px; border-radius:12px; box-shadow:0 10px 25px rgba(15,23,42,0.3); font-size:13px; display:flex; flex-direction:column; gap:4px; min-width:220px;}
    .toast strong{font-weight:700;}
    .toast button{align-self:flex-start; margin-top:4px; height:26px; padding:0 10px; border-radius:8px; border:none; background:#22c55e; color:#064e3b; font-weight:600; cursor:pointer;}
    .toast.fade{opacity:0; transition:opacity 0.3s ease;}
    .segment-hint{position:absolute; transform:translate(-50%,-50%); border-radius:50%; border:2px solid rgba(245,158,11,0.9); box-shadow:0 0 12px rgba(245,158,11,0.5); width:60px; height:60px; pointer-events:none; opacity:0; animation:hint-pop 2s ease-out forwards;}
    @keyframes hint-pop{0%{opacity:0; transform:translate(-50%,-50%) scale(0.8);}20%{opacity:1; transform:translate(-50%,-50%) scale(1);}80%{opacity:1;}100%{opacity:0; transform:translate(-50%,-50%) scale(1.2);}}
    .routeItem { background:rgba(255,255,255,0.9); border:1px solid #d7ece3; border-radius:10px; padding:10px; margin-top:8px; cursor:pointer; transition:box-shadow 0.2s, border-color 0.2s; }
    .routeItem.active { border-color:#34d399; box-shadow:0 0 0 2px rgba(52,211,153,0.25); }
    .routeItem .routeTitle { display:flex; align-items:center; justify-content:space-between; font-weight:600; color:#0f172a; }
    .routeItem input[type="color"] { border:none; background:transparent; width:36px; height:24px; cursor:pointer; }
    .routeItem input[type="text"] { flex:1; min-width:120px; border:1px solid #d1e7dc; border-radius:6px; padding:4px 6px; font-size:13px; font-weight:600; color:#0f172a; background:#f9fffc; }
    .routeItem .routeMeta { display:flex; align-items:center; gap:10px; margin-top:8px; font-size:13px; color:#475569; flex-wrap:wrap; }
    .routeItem label { display:flex; align-items:center; gap:4px; font-size:12px; color:#475569; }
    .stopMarker { position:absolute; width:18px; height:18px; border-radius:50%; transform:translate(-50%,-50%); border:2px solid #ecfdf5; box-shadow:0 0 0 2px rgba(13,148,136,0.15); pointer-events:none; display:flex; align-items:center; justify-content:center; background:#059669; z-index:4; }
    .stopMarker .stopCore { width:6px; height:6px; border-radius:50%; background:#ecfdf5; box-shadow:0 0 3px rgba(15,23,42,0.25) inset; flex-shrink:0; }
    .coach{ background:#ecfdf5; color:#065f46; border:1px solid #a7f3d0; border-radius:10px; padding:8px 12px; font-size:13px; }
    .coach-tip {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: #ecfdf5;
      border: 1px solid #a7f3d0;
      color: #064e3b;
      border-radius: 10px;
      padding: 8px 14px;
      font-size: 13px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      opacity: 0;
      transition: opacity .4s;
      pointer-events: none;
      max-width: 600px;
      text-align: center;
    }
    .coach-tip.visible { opacity: 1; }
    .halo{ position:absolute; border-radius:50%; border:1px dashed rgba(16,185,129,.55); background:rgba(16,185,129,.10); pointer-events:none; transform:translate(-50%,-50%); }
    .mapTip{ position:absolute; z-index:25; padding:6px 8px; background:#111827; color:#fff; border-radius:8px; font-size:12px; pointer-events:none; transform:translate(-50%,-100%); white-space:nowrap; display:none; }
    .modalMask{ position:fixed; inset:0; background:rgba(2,6,23,.45); display:none; place-items:center; z-index:50; }
    .modal{ background:#fff; width:min(680px,calc(100vw - 32px)); border-radius:14px; box-shadow:0 10px 30px rgba(2,6,23,.25); padding:18px; }
    .modal h3{ margin:4px 0 8px; }
    @keyframes popupFloat{
      0%{ transform:translate(-50%,-50%) scale(0.5); opacity:0; }
      20%{ transform:translate(-50%,-50%) scale(1.1); opacity:1; }
      100%{ transform:translate(-50%,-150%) scale(1); opacity:0; }
    }
    @keyframes celebrate{
      0%{ transform:translate(-50%,-50%) scale(0.8); opacity:0; }
      100%{ transform:translate(-50%,-50%) scale(1); opacity:1; }
    }
  </style>
</head>
<body>
  <header id="topbar">
    <div class="hstack" id="topbarLeft">
      <strong class="app-title">Transit Draw Game</strong>
    </div>
    <div id="topbarCenter">
      <span id="dayDisplay" style="font-weight:600;">Day 1</span>
      <span style="margin:0 8px;">|</span>
      <span id="goalDisplay">üéØ Goal: <span id="goalRiders">5,000</span> daily riders</span>
    </div>
    <div class="hstack" id="topbarRight">
      <button class="btn" id="play">‚ñ∂ Play</button>
      <button class="btn" id="reset">Reset</button>
      <button class="btn" id="newmap">New City</button>
    </div>
  </header>

  <div id="bannerHost" aria-live="polite"></div>
  <div id="toastHost" aria-live="polite"></div>

  <main id="viewport">
    <div class="grid3">

      <section class="col col-center card" id="centerCol">
        <div class="center-card">
          <div class="center-head">
            <!-- inside the center header above the map -->
            <div id="coach" class="coach" role="status" aria-live="polite">
              Click the map to place stops near üè† homes and üõçÔ∏è destinations. Watch your riders grow instantly!
            </div>
            <div id="statusBar" class="status-bar" aria-live="polite"></div>
          </div>
          <div id="coachTip" class="coach-tip"></div>
          <div class="map-wrap"><div id="mapSquare"><div class="gridLines"></div></div></div>
          <div class="center-foot muted">
            <b>How to play:</b> Click [+ Add Route] ‚Üí Click the map to place stops ‚Üí Press ‚ñ∂ Play to see it run ‚Üí Goal: Connect homes and destinations to hit your rider target!
          </div>
        </div>
      </section>

      <aside class="col col-scroll card" id="rightCol">
        <div class="section" id="routesPanel">
          <div class="hstack" style="justify-content:space-between;">
            <strong>Routes</strong>
            <button class="btn" id="addRoute">+ Add Route</button>
          </div>
          <div id="routeList" style="margin-top:12px;"></div>
        </div>
        <div class="section" id="networkSummary" style="border-top:2px solid #d1fae5; padding-top:16px;">
          <strong style="font-size:15px;">Your Network</strong>
          <div style="margin-top:12px; font-size:14px;">
            <div><span class="muted">Total:</span> <strong id="totalRiders" style="font-size:20px; color:#059669;">0</strong> daily riders</div>
            <div style="margin-top:6px;"><span class="muted">Goal:</span> <strong id="goalRidersSidebar">5,000</strong> riders</div>
            <div id="progressBar" style="margin-top:10px; height:8px; background:#e5e7eb; border-radius:4px; overflow:hidden;">
              <div id="progressFill" style="width:0%; height:100%; background:#10b981; transition:width 0.3s;"></div>
            </div>
          </div>
        </div>
      </aside>
    </div>
  </main>

  <div id="helpMask" class="modalMask">
    <div class="modal">
      <h3>Transit Draw Game - How to Play</h3>
      <ol style="line-height:1.8;">
        <li><b>Click [+ Add Route]</b> to create your first route.</li>
        <li><b>Click the map</b> to place stops near homes üè† and destinations (üõçÔ∏è üè´ üè¢ üçî üé° üè•).</li>
        <li><b>Watch the numbers!</b> Each stop shows you instantly how many riders you'll get.</li>
        <li><b>Press ‚ñ∂ Play</b> to see your transit network in action.</li>
        <li><b>Goal:</b> Connect enough homes and destinations to hit your daily rider target!</li>
      </ol>
      <p style="font-size:13px;color:#059669; font-weight:600;">üí° Tip: The more homes AND destinations a route covers, the more riders you get!</p>
      <p style="font-size:12px;color:#64748b">Shortcuts: Press <b>N</b> for new route, <b>Esc</b> to deselect route.</p>
      <div style="text-align:right; margin-top:10px;">
        <button class="btn" id="closeHelp">Got it!</button>
      </div>
    </div>
  </div>

  <script>
  const $ = s=>document.querySelector(s), $$ = s=>[...document.querySelectorAll(s)];
  const rand=n=>Math.floor(Math.random()*n);

  // --- CONFIG (tweak later)
  const GRID=20;          // tiles per side
  const HOMES=60;         // number of homes emoji
  const POIS=24;          // number of POIs emoji
  const POI_TYPES=['üõçÔ∏è','üè´','üé°','üè•','üè¢','üçî'];
  const ATTR = {         // attractiveness by type (rough)
    'üõçÔ∏è':1.2,'üè´':1.0,'üé°':0.8,'üè•':0.6,'üè¢':0.9,'üçî':0.7
  };
  const DIST_DECAY=0.06;  // higher ‚Üí fewer long trips
  const TRIPS_PER_HOME=8; // target avg daily trips per home (both ways counted as 2)
  const MAX_VEHICLES=10;  // garage capacity
  const KM_PER_TILE=0.4;  // rough size of one tile in km
  const AVG_SPEED_KPH=22; // average operating speed
  const DWELL_PER_STOP_MIN=0.5; // dwell time per stop in minutes
  const TARGET_HEADWAY_MIN=10;  // target headway passengers expect
  const MIN_LOOP_MINUTES=5;     // minimum practical loop cycle
  const MINUTES_PER_DAY=24*60;
  const SERVICE_START=6*60;
  const SERVICE_END=22*60;
  const VEHICLE_COST_PER_HOUR=95;
  const BASE_CASH=5_000_000;
  const FARE_MIN=1.5;
  const FARE_MAX=3.0;
  const FARE_STEP=0.05;
  const DEFAULT_FARE=2.0;
  const DEFAULT_STOP_COLOR="#059669";

  // --- GAME CONFIG
  let goalRiders = 5000;  // Daily rider goal
  let totalDailyRiders = 0;

  let simMinute=SERVICE_START;
  let simDay=1;
  let simRunning=false;
  let simTimer=null;
  let simSpeed=1;
  let cash=BASE_CASH;
  let fare=DEFAULT_FARE;
  let ridersToday=0;
  let revenueToday=0;
  let expensesToday=0;
  let lastRidershipHr=0;
  let lastVehiclesUsed=0;

  window.TS = window.TS || {};
  if(window.TS.cityName === undefined) window.TS.cityName = "Tutorial City";
  if(window.TS.population === undefined) window.TS.population = 100000;
  if(window.TS.goalPct === undefined) window.TS.goalPct = 5;
  if(window.TS.goalDays === undefined) window.TS.goalDays = 30;

  // --- MAP SIZING (square fits viewport)
  function sizeMap(){
    const map=$("#mapSquare"),wrap=$("#centerCol .map-wrap");
    const avail=Math.min(wrap.clientWidth,wrap.clientHeight);
    const cell=Math.max(30, Math.floor(avail/GRID)), size=cell*GRID;
    map.style.width=size+"px"; map.style.height=size+"px";
    map.querySelector(".gridLines").style.backgroundSize=cell+"px "+cell+"px";
    map.dataset.cell=cell;
    ensureMapOverlays();
    repositionStops();
    renderRouteOverlays();
  }

  function ensureMapOverlays(){
    const map=$("#mapSquare");
    if(!haloLayer){
      haloLayer=document.createElement("div");
      haloLayer.style.position="absolute";
      haloLayer.style.inset="0";
      haloLayer.style.pointerEvents="none";
      haloLayer.style.zIndex="2";
      map.appendChild(haloLayer);
    }
    if(!tipEl){ tipEl=document.createElement("div"); tipEl.className="mapTip"; map.appendChild(tipEl); }
  }

  // --- STATE
  let homes=[], pois=[];
  let od=[]; // list of {ox,oy,dx,dy,tripsPerDay,type,dist}
  let inspectorOn=false, heatOn=false;
  let stops=new Map(); // key "x,y" -> {id,x,y,el,usage}
  let routes=[]; // list of {id,name,color,vehicles,stops:[],projectedHr}
  let editingRouteId=null;
  let routeSeq=1;
  let routeOverlayLayer=null;
  let haloLayer=null, tipEl=null;
  const seenStatusBanners=new Set();
  let coachDayTipTriggered=false;

  // --- helpers
  function addTile(emoji,gx,gy,scale=1){
    const map=$("#mapSquare");
    const d=document.createElement("div");
    d.className="tile";
    d.dataset.gx=gx; d.dataset.gy=gy; d.dataset.scale=scale;
    d.textContent=emoji;
    map.appendChild(d);
    return d;
  }

  function layoutTiles(){
    const map=$("#mapSquare");
    const cell=parseInt(map.dataset.cell||"24",10);
    const tiles=$$("#mapSquare .tile");
    const base = Math.max(16, Math.round(cell*0.75));
    for(const el of tiles){
      const gx=+el.dataset.gx, gy=+el.dataset.gy, sc=+(el.dataset.scale||1);
      el.style.left = (gx*cell + cell/2) + "px";
      el.style.top  = (gy*cell + cell/2) + "px";
      el.style.fontSize = Math.round(base*sc) + "px";
    }
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  function stopKey(gx,gy){ return `${gx},${gy}`; }

  function clamp(min,max,value){
    return Math.min(max, Math.max(min, value));
  }

  function cellSize(){ return parseInt($("#mapSquare").dataset.cell||"24",10); }
  function tileCenter(gx,gy){ const c=cellSize(); return {x:gx*c+c/2,y:gy*c+c/2}; }

  function nearbyTiles(gx,gy,radius=1){
    const results=[];
    const seen=new Set();
    const r=Math.max(0, Math.ceil(radius));
    for(let dx=-r; dx<=r; dx++){
      for(let dy=-r; dy<=r; dy++){
        const x=gx+dx, y=gy+dy;
        if(x<0 || y<0 || x>=GRID || y>=GRID) continue;
        if(Math.hypot(dx,dy) > radius + 0.01) continue;
        const key=`${x},${y}`;
        if(seen.has(key)) continue;
        seen.add(key);
        results.push({x,y});
      }
    }
    return results;
  }

  function tileAt(gx,gy){
    for(const h of homes){ if(h.x===gx && h.y===gy) return {emoji:'üè†'}; }
    for(const p of pois){ if(p.x===gx && p.y===gy) return {emoji:p.type}; }
    return null;
  }

  function showCoachTip(msg, ms=4000){
    const tip=document.getElementById('coachTip');
    if(!tip) return;
    tip.textContent=msg;
    tip.classList.add('visible');
    clearTimeout(tip._t);
    tip._t=setTimeout(()=>tip.classList.remove('visible'), ms);
  }

  function priceFactorForFare(value=fare){
    const baseline = 1 - 0.10*((value-2.0)/0.5);
    return clamp(0.5, 1.5, baseline);
  }

  function formatRidersHr(hr){
    if(!isFinite(hr) || hr <= 0) return '0';
    if(hr < 0.5) return '0';
    if(hr < 1) return '‚âà1';
    return String(Math.round(hr));
  }

  function routeHealth(route){
    const hasOD = ((route?.servedTripsPerDay)||0) > 0;
    const headwayOk = (route?.headway || Infinity) <= 12;
    if(!hasOD) return 'NO_OD';
    if(!headwayOk) return 'LONG_HEADWAY';
    return 'OK';
  }

  function clearHalos(){ if(haloLayer) haloLayer.innerHTML=""; }
  function drawCatchmentsForRoute(route){
    ensureMapOverlays(); clearHalos();
    if(!route) return;
    const c=cellSize(), r=(1+0.5)*c*2; // catchment radius ~1 tile
    const seen=new Set();
    for(const sid of route.stops){
      const s=stopIdToCoords(sid); if(!s) continue;
      const k=s.x+","+s.y; if(seen.has(k)) continue; seen.add(k);
      const p=tileCenter(s.x,s.y);
      const d=document.createElement("div");
      d.className="halo";
      d.style.width=r+"px"; d.style.height=r+"px";
      d.style.left=p.x+"px"; d.style.top=p.y+"px";
      haloLayer.appendChild(d);
    }
  }

  function computeServedTripsForTemp(route, gx, gy){
    const key=stopKey(gx,gy);
    const existed=stops.has(key);
    const temp = { ...route, stops:[...route.stops] };
    const stop=ensureStop(gx,gy); // ensures marker but we‚Äôll revert usage
    const id=stop.id;
    if(!temp.stops.includes(id)) temp.stops.push(id);
    updateRouteMetrics(temp);
    if(!existed){
      removeStopMarkerIfUnused(stop);
    }
    // revert temp marker usage so we don't leak markers
    stop.usage=(stop.usage||0);
    return temp.servedTripsPerDay||0;
  }

  function stopIdToCoords(stopId){
    if(!stopId) return null;
    const key=stopId.startsWith('s') ? stopId.slice(1) : stopId;
    const stop=stops.get(key);
    if(!stop) return null;
    return {x:stop.x, y:stop.y};
  }

  function routeStopCoords(route){
    if(!route) return [];
    const coords=[];
    const seen=new Set();
    for(const stopId of route.stops){
      if(seen.has(stopId)) continue;
      const c=stopIdToCoords(stopId);
      if(c){ coords.push(c); seen.add(stopId); }
    }
    return coords;
  }

  function ensureRouteOverlay(){
    const map=$("#mapSquare");
    if(!map) return null;
    if(!routeOverlayLayer || routeOverlayLayer.parentNode!==map){
      routeOverlayLayer=document.createElement("div");
      routeOverlayLayer.className="routeOverlay";
      map.appendChild(routeOverlayLayer);
    }
    return routeOverlayLayer;
  }

  function renderRouteOverlays(){
    const map=$("#mapSquare");
    if(!map) return;
    const layer=ensureRouteOverlay();
    if(!layer) return;
    const cell=parseInt(map.dataset.cell||"24",10);
    const size=cell*GRID;
    layer.innerHTML="";
    const svg=document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute("viewBox",`0 0 ${size} ${size}`);
    svg.setAttribute("width", size);
    svg.setAttribute("height", size);
    layer.appendChild(svg);
    const strokeWidth=Math.max(2, Math.round(cell*0.12));
    for(const route of routes){
      const coords=routeStopCoords(route);
      if(coords.length<2) continue;
      const points=coords.map(c=>`${c.x*cell+cell/2},${c.y*cell+cell/2}`).join(" ");
      const polyline=document.createElementNS("http://www.w3.org/2000/svg","polyline");
      polyline.setAttribute("points", points);
      polyline.setAttribute("fill", "none");
      polyline.setAttribute("stroke", route.color || DEFAULT_STOP_COLOR);
      polyline.setAttribute("stroke-width", strokeWidth);
      polyline.setAttribute("stroke-linecap", "round");
      polyline.setAttribute("stroke-linejoin", "round");
      svg.appendChild(polyline);
    }
  }

  function computeLoopMinutes(route){
    const coords=routeStopCoords(route);
    if(coords.length<2){
      return Math.max(MIN_LOOP_MINUTES, coords.length * DWELL_PER_STOP_MIN || MIN_LOOP_MINUTES);
    }
    let tileDistance=0;
    for(let i=0;i<coords.length;i++){
      const a=coords[i];
      const b=coords[(i+1)%coords.length];
      tileDistance+=Math.hypot(a.x-b.x, a.y-b.y);
    }
    const travelKm=tileDistance*KM_PER_TILE;
    const travelMinutes=(travelKm/AVG_SPEED_KPH)*60;
    const dwellMinutes=coords.length*DWELL_PER_STOP_MIN;
    return Math.max(MIN_LOOP_MINUTES, travelMinutes+dwellMinutes);
  }

  function escapeHTML(str){
    return (str??'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]||c));
  }

  function ensureStop(gx,gy){
    const key=stopKey(gx,gy);
    const map=$("#mapSquare");
    const cell=parseInt(map.dataset.cell||"24",10);
    if(stops.has(key)){
      const existing=stops.get(key);
      if(!existing.routes) existing.routes=new Set();
      const size=Math.max(14, Math.round(cell*0.45));
      existing.el.style.width=size+"px";
      existing.el.style.height=size+"px";
      let core=existing.el.querySelector('.stopCore');
      if(!core){
        core=document.createElement("div");
        core.className="stopCore";
        existing.el.appendChild(core);
      }
      if(core){
        const coreSize=Math.max(4, Math.round(size*0.35));
        core.style.width=coreSize+"px";
        core.style.height=coreSize+"px";
      }
      updateStopColors(existing);
      return existing;
    }
    const marker=document.createElement("div");
    marker.className="stopMarker";
    const size=Math.max(14, Math.round(cell*0.45));
    marker.style.width=size+"px";
    marker.style.height=size+"px";
    marker.style.left=(gx*cell+cell/2)+"px";
    marker.style.top =(gy*cell+cell/2)+"px";
    const core=document.createElement("div");
    core.className="stopCore";
    const coreSize=Math.max(4, Math.round(size*0.35));
    core.style.width=coreSize+"px";
    core.style.height=coreSize+"px";
    marker.appendChild(core);
    map.appendChild(marker);
    const stop={id:`s${key}`,x:gx,y:gy,el:marker,usage:0,routes:new Set()};
    stops.set(key,stop);
    updateStopColors(stop);
    return stop;
  }

  function removeStopMarkerIfUnused(stop){
    if(stop.usage<=0){
      if(stop.el && stop.el.parentNode) stop.el.parentNode.removeChild(stop.el);
      if(stop.routes) stop.routes.clear();
      stops.delete(stopKey(stop.x,stop.y));
    }
  }

  function resetAllStops(){
    stops.forEach(s=>{ if(s.el && s.el.parentNode) s.el.parentNode.removeChild(s.el); });
    stops.clear();
    renderRouteOverlays();
  }

  function repositionStops(){
    const cell=parseInt($("#mapSquare").dataset.cell||"24",10);
    stops.forEach(stop=>{
      stop.el.style.left=(stop.x*cell+cell/2)+"px";
      stop.el.style.top =(stop.y*cell+cell/2)+"px";
      const size=Math.max(14, Math.round(cell*0.45));
      stop.el.style.width=size+"px";
      stop.el.style.height=size+"px";
      const core=stop.el.querySelector('.stopCore');
      if(core){
        const coreSize=Math.max(4, Math.round(size*0.35));
        core.style.width=coreSize+"px";
        core.style.height=coreSize+"px";
      }
      updateStopColors(stop);
    });
  }

  function updateStopColors(stop){
    if(!stop || !stop.el) return;
    if(!stop.routes) stop.routes=new Set();
    const colors=[];
    const validIds=new Set();
    for(const route of routes){
      if(stop.routes.has(route.id)){
        colors.push(route.color || DEFAULT_STOP_COLOR);
        validIds.add(route.id);
      }
    }
    for(const id of [...stop.routes]){
      if(!validIds.has(id)){
        stop.routes.delete(id);
      }
    }
    let background=DEFAULT_STOP_COLOR;
    if(colors.length===1){
      background=colors[0];
    }else if(colors.length>1){
      let angle=0;
      const total=colors.length;
      const segments=colors.map((color,index)=>{
        const start=angle;
        const span=index===total-1 ? 360-start : 360/total;
        angle+=span;
        const end=start+span;
        return `${color} ${start}deg ${end}deg`;
      });
      background=`conic-gradient(${segments.join(',')})`;
    }
    stop.el.style.background=background;
    const core=stop.el.querySelector('.stopCore');
    if(core){
      core.style.background='#ecfdf5';
    }
  }

  function refreshStopsForRoute(route){
    if(!route) return;
    for(const stopId of route.stops){
      const key=stopId.startsWith('s') ? stopId.slice(1) : stopId;
      const stop=stops.get(key);
      if(stop){
        if(!stop.routes) stop.routes=new Set();
        stop.routes.add(route.id);
        updateStopColors(stop);
      }
    }
  }

  function resetRoutes(){
    routes.length=0;
    editingRouteId=null;
    routeSeq=1;
    resetAllStops();
    renderRoutesPanel();
    clearHalos();
    if(tipEl) tipEl.style.display="none";
    updateRouteStats();
    updateRouteDetails();
    updateEditingStatus();
    seenStatusBanners.clear();
    coachDayTipTriggered=false;
  }

  function makeRoute(){
    const id=`r${routeSeq++}`;
    const colors=['#1d4ed8','#dc2626','#047857','#9333ea','#f59e0b','#0891b2'];
    const color=colors[(routes.length)%colors.length];
    const route={id,name:`Route ${routes.length+1}`,color,vehicles:1,stops:[],loopMinutes:MIN_LOOP_MINUTES,headway:Infinity,servedTripsPerDay:0,projectedHr:0,dailyRiders:0,liveRidersThisHour:0,lastHealth:'NO_OD',connectionToastShown:false,suggestedVehicleToast:false,firstRidersToastShown:false};
    routes.push(route);
    selectRoute(id);
    renderRoutesPanel();
    updateRouteStats();
    return route;
  }

  function selectRoute(id){
    editingRouteId=id;
    if(inspectorLayer) inspectorLayer.innerHTML="";
    renderRoutesPanel();
    updateRouteDetails();
    updateEditingStatus();
    const route=routes.find(r=>r.id===id);
    drawCatchmentsForRoute(route);
    updateRiderNumbersUI(route||null);
    if(tipEl) tipEl.style.display="none";
  }

  function routeStopCount(route){
    return route ? route.stops.length : 0;
  }

  function updateRiderNumbersUI(route){
    const activeRoute = route || routes.find(r=>r.id===editingRouteId) || null;
    const liveTotal = Math.round(window.TS?.liveRidersPerHour || 0);
    const routeLive = Math.round(activeRoute?.liveRidersThisHour || 0);
    const projectedTotal = window.TS?.projectedRidersPerHour ?? 0;

    const liveEl = document.getElementById('liveRidersHr');
    const projEl = document.getElementById('projRidersHr');
    const projInline = document.getElementById('projRidersHrInline');
    const status = activeRoute ? routeHealth(activeRoute) : null;
    const liveDisplay = activeRoute ? routeLive : liveTotal;
    if(liveEl) liveEl.textContent = liveDisplay.toLocaleString();
    if(projEl){
      if(activeRoute){
        const projectedDisplay = (activeRoute.projectedHr>0 || status==='OK') ? formatRidersHr(activeRoute.projectedHr||0) : '‚Äî';
        projEl.textContent = projectedDisplay;
      }else{
        projEl.textContent = formatRidersHr(projectedTotal);
      }
    }

    if(projInline && activeRoute){
      const label = (activeRoute.projectedHr>0 || status==='OK') ? formatRidersHr(activeRoute.projectedHr||0) : '‚Äî';
      projInline.textContent = label;
    }else if(projInline){
      projInline.textContent = formatRidersHr(projectedTotal);
    }

    const tag = document.getElementById('liveStatusTag');
    if(tag){
      const paused = !!window.TS?.paused;
      tag.textContent = paused ? 'paused' : 'live';
      tag.style.background = paused ? '#fee2e2' : '#dcfce7';
      tag.style.color = paused ? '#991b1b' : '#166534';
    }

    const reason = document.getElementById('liveReason');
    if(!reason) return;

    if(!activeRoute){
      reason.textContent = '';
      return;
    }

    let message = '';
    if(window.TS?.paused){
      message = 'Simulation is paused ‚Äî press ‚ñ∂ Play to start service.';
    }else if((window.TS?.clockMins ?? 0) < SERVICE_START || (window.TS?.clockMins ?? 0) >= SERVICE_END){
      message = 'Outside service hours right now.';
    }else if(activeRoute.vehicles <= 0){
      message = 'No vehicles assigned yet ‚Äî add at least one to begin service.';
    }else if(status === 'NO_OD'){
      message = 'Needs homes & destinations. Place stops so a üè† and üéØ overlap catchments.';
    }else if(status === 'LONG_HEADWAY'){
      message = 'Too infrequent right now. Add vehicles or shorten the loop to improve headway.';
    }else if(routeLive === 0 && (activeRoute.projectedHr||0) > 0){
      message = 'No riders yet ‚Äî give the first vehicle a moment to reach stops.';
    }else{
      message = '';
    }

    reason.textContent = message;
  }

  function updateRouteMetrics(route){
    const coords=routeStopCoords(route);
    const loopMinutes=computeLoopMinutes(route);

    // AUTO-CALCULATE VEHICLES based on loop length (simple game mechanic)
    const autoVehicles = coords.length < 2 ? 0 : Math.max(1, Math.min(MAX_VEHICLES, Math.ceil(loopMinutes / 15)));
    route.vehicles = autoVehicles;

    const headway=autoVehicles>0 ? loopMinutes/autoVehicles : Infinity;
    route.loopMinutes=loopMinutes;
    route.headway=headway;

    route.projectedHr=0;
    route.dailyRiders=0;

    const countedTiles=new Set();
    let homesCount=0, destsCount=0;
    for(const c of coords){
      const nearby=nearbyTiles(c.x, c.y, 1);
      for(const t of nearby){
        const key=`${t.x},${t.y}`;
        if(countedTiles.has(key)) continue;
        countedTiles.add(key);
        const tile=tileAt(t.x,t.y);
        if(tile?.emoji==='üè†') homesCount++;
        else if(['üõçÔ∏è','üè´','üè¢','üçî','üé°','üè•'].includes(tile?.emoji)) destsCount++;
      }
    }
    route.coveredHomes=homesCount;
    route.coveredDests=destsCount;

    if(coords.length<2){
      route.servedTripsPerDay=0;
      return;
    }

    // SIMPLIFIED RIDERSHIP: Just based on coverage
    // Each home-destination pair covered = ~50 daily riders
    const ridersPerPair = 50;
    const dailyRiders = Math.round(homesCount * destsCount * ridersPerPair * 0.1); // Scale factor
    route.dailyRiders = dailyRiders;
    route.servedTripsPerDay = dailyRiders;

    const serviceHours=Math.max(1, (SERVICE_END-SERVICE_START)/60);
    route.projectedHr = dailyRiders / serviceHours;
  }

  function getHeadwayFeedback(headwayMin, cityPop, routeDemand) {
    if (headwayMin <= 15) return null; // always fine

    // early game leniency
    if (cityPop <= 200000) {
      if (headwayMin > 35) return "Ridership might stay low with 35+ min gaps. A second vehicle could help.";
      if (headwayMin > 25) return "Running every ~" + headwayMin + " min. Fine for now, but an extra bus would help.";
      return null;
    }

    // mid-size city
    if (cityPop <= 500000) {
      if (headwayMin > 30) return "This corridor might need more frequent service.";
      if (headwayMin > 20) return "Every " + headwayMin + " min is okay, but not ideal.";
      return null;
    }

    // big city
    if (headwayMin > 20) return "Pretty infrequent for a bus route of this scale.";
    if (headwayMin > 15) return "Riders might wait a while ‚Äî consider adding vehicles.";
    return null;
  }

  function analyzeRoute(route){
    if(!route) return;
    const served=route.servedTripsPerDay || 0;
    const homes=route.coveredHomes || 0;
    const dests=route.coveredDests || 0;
    const headway=route.headway ?? Infinity;
    const veh=route.vehicles || 0;
    const ridership=Math.max(route.projectedHr||0, route.liveRidersThisHour||0);

    if(homes===0 && dests===0){
      showCoachTip("This route doesn't reach anyone. Try hitting a few üè† or üõçÔ∏è squares.");
      return;
    }
    if(homes>0 && dests===0){
      showCoachTip("People like going other places too lol. Add a stop near a shop, job, or school.");
      return;
    }
    if(dests>0 && homes===0){
      showCoachTip("Plenty of places to go, but no one to go there from. Add some homes üè†.");
      return;
    }
    if(served===0){
      showCoachTip("You‚Äôre close! Stops might be too far apart to cover both ends of a trip.");
      return;
    }
    const population = window.TS?.population ?? 100000;
    const headwayMessage = getHeadwayFeedback(headway, population, served);
    if(headwayMessage){
      showCoachTip(headwayMessage);
      return;
    }
    if(headway<6 && veh>4){
      showCoachTip("Frequent service! Might be time to boost ridership or extend the route.");
      return;
    }
    if(served>0 && ridership>0){
      showCoachTip("Nice. You‚Äôve got a working line. Keep it balanced between homes and destinations.");
    }
  }

  function updateRouteStats(){
    let vehiclesUsed=0, projectedTotal=0;
    for(const route of routes){
      updateRouteMetrics(route);
      if(route.id===editingRouteId){
        updateRouteBreakdownUI(route);
        renderRouteStatusChip(route);
      }
      vehiclesUsed+=route.vehicles;
      projectedTotal+=route.projectedHr||0;
    }
    lastVehiclesUsed=vehiclesUsed;
    lastRidershipHr=projectedTotal;
    window.TS = window.TS || {};
    window.TS.projectedRidersPerHour = projectedTotal;
    const spare=Math.max(0, MAX_VEHICLES-vehiclesUsed);
    const vehLabel=$("#veh");
    if(vehLabel) vehLabel.textContent=`${vehiclesUsed} / ${MAX_VEHICLES} (Spare: ${spare})`;
    const active=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(active||null);
  }

  function updateRouteBreakdownUI(route){
    if(!route) return;
    const serviceHours = Math.max(1, (SERVICE_END-SERVICE_START)/60);
    const served = route.servedTripsPerDay||0;
    const demandHr = served/serviceHours;
    const veh = Math.max(0, Number(route.vehicles)||0);
    const loopHours = route.loopMinutes ? route.loopMinutes/60 : 0;
    const vehPerHr = (loopHours>0 && veh>0) ? (veh / loopHours) : 0;
    const capHr = vehPerHr * 45;
    const waitFactor = (route.headway>0 && isFinite(route.headway)) ? Math.min(1, TARGET_HEADWAY_MIN/Math.max(route.headway,0.0001)) : 0;
    const fareNow = fare;
    const priceFactor = priceFactorForFare(fareNow);
    const baseline = Math.min(demandHr, capHr);
    const projected = route.projectedHr || 0;
    const status = routeHealth(route);
    const projectedLabel = (projected>0 || status==='OK') ? formatRidersHr(projected) : '‚Äî';
    const demandDisplay = Number.isFinite(demandHr) ? demandHr.toFixed(1) : '0.0';
    const vehPerHrDisplay = Number.isFinite(vehPerHr) ? vehPerHr.toFixed(2) : '0.00';
    const capHrDisplay = Number.isFinite(capHr) ? capHr.toFixed(0) : '0';
    const waitDisplay = Number.isFinite(waitFactor) ? waitFactor.toFixed(2) : '0.00';
    const priceDisplay = Number.isFinite(priceFactor) ? priceFactor.toFixed(2) : '0.00';
    const baselineDisplay = Number.isFinite(baseline) ? baseline.toFixed(1) : '0.0';

    const container=document.getElementById("routeDetails");
    if(!container) return;
    const box = document.getElementById("routeBreakdown") || (() => {
      const el=document.createElement("div");
      el.id="routeBreakdown"; el.className="muted"; el.style.marginTop="8px";
      container.appendChild(el);
      return el;
    })();

    box.innerHTML = `
      <div><strong>Projected riders/hr = <span id="projRidersHrInline">${projectedLabel}</span> <span class="muted">/ hr</span></strong></div>
      <div>Served trips/day (both ends covered): <b>${served.toLocaleString()}</b></div>
      <div>Demand/hr = served √∑ ${serviceHours} = <b>${demandDisplay}</b></div>
      <div>Capacity/hr = (vehicles/loop hr) √ó 45 = <b>${vehPerHrDisplay}</b> √ó 45 = <b>${capHrDisplay}</b></div>
      <div>Headway factor (target ${TARGET_HEADWAY_MIN}m): <b>${waitDisplay}</b></div>
      <div>Price factor (@ $${fareNow.toFixed(2)}): <b>${priceDisplay}</b></div>
      <div>Riders/hr ‚âà min(demand, capacity) √ó headway √ó price = <b>${baselineDisplay}</b> √ó ${waitDisplay} √ó ${priceDisplay}</div>
    `;
  }

  function ensureDemandHeatOn(){
    heatOn = true;
    const toggle=document.getElementById('toggleDemandHeat');
    if(toggle) toggle.checked = true;
    renderHeat();
  }

  function incrementVehicles(route){
    if(!route) return;
    const next=Math.min(MAX_VEHICLES, (route.vehicles||0)+1);
    if(next===route.vehicles) return;
    route.vehicles=next;
    updateRouteStats();
    updateRouteDetails();
    renderRoutesPanel();
    analyzeRoute(route);
  }

  function showShortenLoopTips(route){
    if(!route) return;
    ensureMapOverlays();
    const coords=routeStopCoords(route);
    if(coords.length<2) return;
    let best=-1, bestIdx=0;
    for(let i=0;i<coords.length;i++){
      const a=coords[i];
      const b=coords[(i+1)%coords.length];
      const d=Math.hypot(a.x-b.x, a.y-b.y);
      if(d>best){ best=d; bestIdx=i; }
    }
    if(best<=0) return;
    const a=coords[bestIdx];
    const b=coords[(bestIdx+1)%coords.length];
    const points=[a,b];
    for(const p of points){
      const center=tileCenter(p.x,p.y);
      const hint=document.createElement('div');
      hint.className='segment-hint';
      hint.style.left=center.x+'px';
      hint.style.top=center.y+'px';
      haloLayer && haloLayer.appendChild(hint);
      setTimeout(()=>{ hint.remove(); }, 2400);
    }
    if(tipEl){
      const aCenter=tileCenter(a.x,a.y);
      const bCenter=tileCenter(b.x,b.y);
      tipEl.style.left=((aCenter.x+bCenter.x)/2)+'px';
      tipEl.style.top =((aCenter.y+bCenter.y)/2)+'px';
      tipEl.textContent='Remove one of these stops to shorten the loop.';
      tipEl.style.display='block';
      setTimeout(()=>{ if(tipEl) tipEl.style.display='none'; }, 2400);
    }
  }

  function showToast(title, body='', action){
    const host=document.getElementById('toastHost');
    if(!host) return;
    const toast=document.createElement('div');
    toast.className='toast';
    const remove=()=>{
      if(!toast.parentElement) return;
      toast.classList.add('fade');
      setTimeout(()=>{ toast.remove(); }, 320);
    };
    if(title){
      const strong=document.createElement('strong');
      strong.textContent=title;
      toast.appendChild(strong);
    }
    if(body){
      const span=document.createElement('span');
      span.textContent=body;
      toast.appendChild(span);
    }
    if(action && action.label){
      const btn=document.createElement('button');
      btn.textContent=action.label;
      btn.addEventListener('click',()=>{
        if(action.onClick) action.onClick();
        remove();
      });
      toast.appendChild(btn);
    }
    host.appendChild(toast);
    const duration = action?.duration ?? 5000;
    setTimeout(remove, duration);
  }

  function getRouteStatusContent(route){
    const status=routeHealth(route);
    const headwayLabel = (route.vehicles>0 && isFinite(route.headway)) ? route.headway.toFixed(1)+'m' : '‚Äî';
    const base={status,label:'',tip:'',actions:[],tone: status==='OK' ? 'ok' : 'warn'};
    if(status==='NO_OD'){
      base.label='Needs homes & destinations';
      base.tip='Place stops so at least one üè† and one üéØ overlap the green circles.';
      base.actions.push({label:'Show demand heat', onClick:ensureDemandHeatOn});
    }else if(status==='LONG_HEADWAY'){
      base.label=`Too infrequent (headway ${headwayLabel})`;
      base.actions.push({label:'+1 vehicle', onClick:()=>incrementVehicles(route)});
      base.actions.push({label:'Shorten loop tips', onClick:()=>showShortenLoopTips(route), variant:'secondary'});
    }else{
      base.label='Good to go.';
    }
    return base;
  }

  function showStatusBanner(route, content){
    if(!route || !content) return;
    if(seenStatusBanners.has(content.status)) return;
    seenStatusBanners.add(content.status);
    const host=document.getElementById('bannerHost');
    if(!host) return;
    const banner=document.createElement('div');
    banner.className='banner';
    if(content.tone!=='ok') banner.dataset.state='warn';
    const label=document.createElement('span');
    label.textContent=content.label;
    banner.appendChild(label);
    if(content.tip){
      const tip=document.createElement('span');
      tip.className='chip-tip';
      tip.textContent=content.tip;
      banner.appendChild(tip);
    }
    if(content.actions?.length){
      for(const action of content.actions){
        const btn=document.createElement('button');
        btn.textContent=action.label;
        if(action.variant==='secondary') btn.classList.add('secondary');
        btn.addEventListener('click',()=>{ action.onClick && action.onClick(); banner.classList.add('fade'); setTimeout(()=>banner.remove(), 320); });
        banner.appendChild(btn);
      }
    }
    host.appendChild(banner);
    setTimeout(()=>{ banner.classList.add('fade'); setTimeout(()=>banner.remove(), 320); }, 5200);
  }

  function renderRouteStatusChip(route){
    const mount=document.getElementById('routeStatusChipMount');
    if(!mount) return;
    mount.innerHTML='';
    const content=getRouteStatusContent(route);
    if(!content) return;
    const previous=route.lastHealth;
    route.lastHealth=content.status;
    const chip=document.createElement('div');
    chip.className='status-chip';
    chip.dataset.state=content.tone==='ok' ? 'ok' : 'warn';
    const label=document.createElement('span');
    label.textContent=content.label;
    chip.appendChild(label);
    if(content.actions?.length){
      const actions=document.createElement('div');
      actions.className='chip-actions';
      for(const action of content.actions){
        const btn=document.createElement('button');
        btn.className='btn'+(action.variant==='secondary' ? ' secondary' : '');
        btn.textContent=action.label;
        btn.addEventListener('click',(e)=>{ e.stopPropagation(); action.onClick && action.onClick(); });
        actions.appendChild(btn);
      }
      chip.appendChild(actions);
    }
    if(content.tip){
      const tip=document.createElement('div');
      tip.className='chip-tip';
      tip.textContent=content.tip;
      chip.appendChild(tip);
    }
    mount.appendChild(chip);
    showStatusBanner(route, content);
    if(previous==='NO_OD' && content.status!=='NO_OD' && !route.connectionToastShown){
      showToast('Nice‚Äîthis route connects homes and destinations.', 'Press ‚ñ∂ to start service.');
      route.connectionToastShown=true;
      if((route.vehicles||0)>=1 && (route.headway||Infinity) > 12 && !route.suggestedVehicleToast){
        showToast('Headway is a bit long.', 'Add another vehicle to improve frequency.', {label:'+1 vehicle', onClick:()=>incrementVehicles(route)});
        route.suggestedVehicleToast=true;
      }
    }
  }

  function updateRouteDetails(){
    // Simplified - no detailed breakdown needed for the game
  }

  function updateEditingStatus(){
    const foot=$(".center-foot");
    if(!foot) return;
    const route=routes.find(r=>r.id===editingRouteId);
    if(route){
      foot.textContent=`Editing ${route.name}: click the map to add stops ¬∑ Shift-click to remove.`;
    }else if(inspectorOn){
      foot.textContent='Demand inspector active: click a home to view its top destinations.';
    }else{
      foot.textContent='Select a route to begin placing stops. Shift-click tiles to remove stops from the active route.';
    }
  }

  function renderRoutesPanel(){
    const list=$("#routeList");
    if(!list) return;
    list.innerHTML="";
    if(!routes.length){
      list.innerHTML='<div class="muted" style="text-align:center; padding:20px;">No routes yet.<br>Click [+ Add Route] to start!</div>';
      renderRouteOverlays();
      updateNetworkSummary();
      return;
    }
    for(const route of routes){
      const item=document.createElement("div");
      item.className="routeItem"+(route.id===editingRouteId?" active":"");
      item.dataset.route=route.id;

      // Simple display: just color circle, name, and daily riders
      const colorCircle = document.createElement("div");
      colorCircle.style.cssText = `width:20px; height:20px; border-radius:50%; background:${route.color}; flex-shrink:0;`;

      const routeInfo = document.createElement("div");
      routeInfo.style.cssText = "flex:1; display:flex; justify-content:space-between; align-items:center;";

      const nameSpan = document.createElement("span");
      nameSpan.textContent = route.name;
      nameSpan.style.fontWeight = "600";

      const ridersSpan = document.createElement("span");
      const dailyRiders = route.dailyRiders || 0;
      ridersSpan.textContent = `${dailyRiders.toLocaleString()} daily riders`;
      ridersSpan.style.cssText = "color:#059669; font-size:13px;";

      // Dim if no riders
      if(dailyRiders === 0) {
        item.style.opacity = "0.5";
        ridersSpan.style.color = "#94a3b8";
      }

      routeInfo.appendChild(nameSpan);
      routeInfo.appendChild(ridersSpan);

      item.style.cssText = "display:flex; gap:10px; align-items:center; padding:12px; margin-bottom:8px; background:rgba(255,255,255,0.9); border:1px solid #d7ece3; border-radius:10px; cursor:pointer; transition:all 0.2s;";
      item.appendChild(colorCircle);
      item.appendChild(routeInfo);

      item.addEventListener("click",()=>{ selectRoute(route.id); });
      list.appendChild(item);
    }
    renderRouteOverlays();
    updateNetworkSummary();
  }

  function updateNetworkSummary(){
    const totalRidersEl = $("#totalRiders");
    const goalRidersSidebarEl = $("#goalRidersSidebar");
    const progressFillEl = $("#progressFill");

    totalDailyRiders = routes.reduce((sum, r) => sum + (r.dailyRiders || 0), 0);

    if(totalRidersEl) totalRidersEl.textContent = totalDailyRiders.toLocaleString();
    if(goalRidersSidebarEl) goalRidersSidebarEl.textContent = goalRiders.toLocaleString();
    if(progressFillEl) {
      const progress = Math.min(100, (totalDailyRiders / goalRiders) * 100);
      progressFillEl.style.width = progress + "%";
    }

    // Update goal display in header
    const goalRidersHeaderEl = $("#goalRiders");
    if(goalRidersHeaderEl) goalRidersHeaderEl.textContent = goalRiders.toLocaleString();

    // Check win condition
    if(totalDailyRiders >= goalRiders && routes.length > 0) {
      showWinCelebration();
    }
  }

  function addStopToRoute(route,gx,gy){
    const stop=ensureStop(gx,gy);
    if(route.stops.includes(stop.id)){
      return;
    }

    // Store previous riders for delta calculation
    const previousRiders = route.dailyRiders || 0;

    route.stops.push(stop.id);
    stop.usage=(stop.usage||0)+1;
    if(!stop.routes) stop.routes=new Set();
    stop.routes.add(route.id);
    updateStopColors(stop);
    updateRouteMetrics(route);

    // Calculate delta and show popup!
    const newRiders = route.dailyRiders || 0;
    const delta = newRiders - previousRiders;
    if(delta > 0) {
      showRiderPopup(gx, gy, delta);
    }

    analyzeRoute(route);
    updateRouteStats();
    updateRouteDetails();
    renderRoutesPanel();
    renderRouteOverlays();
    drawCatchmentsForRoute(route);
  }

  function showRiderPopup(gx, gy, delta) {
    const map = $("#mapSquare");
    if(!map) return;

    const pos = tileCenter(gx, gy);
    const popup = document.createElement("div");
    popup.style.cssText = `
      position: absolute;
      left: ${pos.x}px;
      top: ${pos.y}px;
      transform: translate(-50%, -50%);
      background: #10b981;
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 18px;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
      animation: popupFloat 1.5s ease-out forwards;
    `;
    popup.textContent = `+${delta} riders! üéâ`;

    map.appendChild(popup);
    setTimeout(() => popup.remove(), 1500);
  }

  function showWinCelebration() {
    // Only show once
    if(window.hasShownWinCelebration) return;
    window.hasShownWinCelebration = true;

    const banner = document.createElement("div");
    banner.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 40px 60px;
      border-radius: 20px;
      font-size: 32px;
      font-weight: bold;
      text-align: center;
      z-index: 1000;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      animation: celebrate 0.6s ease-out;
    `;
    banner.innerHTML = `
      üéâ SUCCESS! üéâ<br>
      <div style="font-size:20px; margin-top:12px; font-weight:normal;">You connected the city!</div>
      <div style="margin-top:20px; display:flex; gap:12px; justify-content:center;">
        <button onclick="tryBiggerCity()" style="padding:12px 24px; background:white; color:#059669; border:none; border-radius:10px; font-weight:600; cursor:pointer; font-size:16px;">Try Bigger City</button>
        <button onclick="location.reload()" style="padding:12px 24px; background:rgba(255,255,255,0.2); color:white; border:none; border-radius:10px; font-weight:600; cursor:pointer; font-size:16px;">Try New Map</button>
      </div>
    `;

    document.body.appendChild(banner);
  }

  window.tryBiggerCity = function() {
    goalRiders = 12000;
    window.hasShownWinCelebration = false;
    document.querySelector("body > div[style*='position: fixed']")?.remove();
    updateNetworkSummary();
  };

  function removeStopFromRoute(route,gx,gy){
    const key=stopKey(gx,gy);
    const stop=stops.get(key);
    if(!stop) return;
    const idx=route.stops.lastIndexOf(stop.id);
    if(idx>-1){
      route.stops.splice(idx,1);
      stop.usage=Math.max(0,(stop.usage||0)-1);
      if(stop.routes) stop.routes.delete(route.id);
      updateStopColors(stop);
      removeStopMarkerIfUnused(stop);
      updateRouteMetrics(route);
      analyzeRoute(route);
      updateRouteStats();
      updateRouteDetails();
      renderRoutesPanel();
      renderRouteOverlays();
      drawCatchmentsForRoute(route);
    }
  }

  function mapClickRouter(e){
    const map=$("#mapSquare");
    if(!map) return;
    const rect=map.getBoundingClientRect();
    const c=cellSize();
    const gx=Math.max(0, Math.min(GRID-1, Math.floor((e.clientX-rect.left)/c)));
    const gy=Math.max(0, Math.min(GRID-1, Math.floor((e.clientY-rect.top )/c)));

    if(inspectorOn && !editingRouteId){
      handleInspectorClick(e);
      return;
    }

    // If a route is selected -> edit that route (add/remove with Shift)
    const active=routes.find(r=>r.id===editingRouteId);

    // If no routes or none selected, first click creates a route and places the first stop
    if(!active){
      const r = makeRoute();              // creates, selects, renders
      addStopToRoute(r, gx, gy);          // first stop
      $("#coach") && ($("#coach").textContent="Great! Keep adding stops where homes üè† and destinations overlap. Press ‚ñ∂Ô∏é Play to start service.");
      drawCatchmentsForRoute(r);
      return;
    }

    if(e.shiftKey){ removeStopFromRoute(active, gx, gy); }
    else{ addStopToRoute(active, gx, gy); }
    drawCatchmentsForRoute(active);
  }

  // --- city generation: homes + destinations
  function generateCityState(){
    homes=[]; pois=[];
    for(let i=0;i<HOMES;i++){
      const gx=Math.min(GRID-1, Math.max(0, rand(GRID) + (rand(3)-1)));
      const gy=Math.min(GRID-1, Math.max(0, rand(GRID) + (rand(3)-1)));
      homes.push({x:gx,y:gy,scale:1+Math.random()*0.3});
    }
    for(let i=0;i<POIS;i++){
      const t=POI_TYPES[rand(POI_TYPES.length)];
      const gx=rand(GRID), gy=rand(GRID);
      pois.push({x:gx,y:gy,type:t,attr:ATTR[t]||1,scale:1.1});
    }
  }

  function renderCityDOM(){
    const map=$("#mapSquare");
    [...map.querySelectorAll(".tile")].forEach(n=>n.remove());
    for(const h of homes){ h.el = addTile('üè†', h.x, h.y, h.scale); }
    for(const p of pois){ p.el = addTile(p.type, p.x, p.y, p.scale); }
    layoutTiles();
  }

  // --- OD generation: for each home, allocate daily trips to top-K nearby POIs by gravity model
  function buildOD(){
    od.length=0;
    let total=0;
    for(const h of homes){
      // score each POI by attractiveness * f(distance)
      const scored=pois.map(p=>{
        const d=dist(h,p);
        const w=p.attr * Math.exp(-DIST_DECAY*d);
        return {p,w,d};
      }).filter(r=>r.w>0.01).sort((a,b)=>b.w-a.w);

      // take top 6 targets, normalize to daily trips
      const top=scored.slice(0,6);
      const sumW=top.reduce((s,r)=>s+r.w,0)||1;
      for(const r of top){
        const share=r.w/sumW;
        const trips=Math.max(0, Math.round(TRIPS_PER_HOME*share));
        if(trips>0){
          od.push({ox:h.x,oy:h.y,dx:r.p.x,dy:r.p.y,tripsPerDay:trips,type:r.p.type,dist:r.d});
          total+=trips;
        }
      }
    }
    const demandSummary = $("#demandSummary");
    if(demandSummary) demandSummary.textContent=`Potential trips/day: ${total.toLocaleString()}`;
    const potentialTrips = $("#potentialTrips");
    if(potentialTrips) potentialTrips.textContent = total.toLocaleString();
    updateRouteStats();
    renderRoutesPanel();
    updateRouteDetails();
  }

  // --- Demand Heat overlay
  function renderHeat(){
    const map=$("#mapSquare");
    let layer=map.querySelector(".demandHeat");
    if(!layer){ layer=document.createElement("div"); layer.className="demandHeat"; map.appendChild(layer); }
    layer.innerHTML="";
    if(!heatOn) return;
    const cell=parseInt(map.dataset.cell||"24",10);
    // intensity per origin
    const byOrigin = new Map();
    for(const t of od){
      const key=t.ox+","+t.oy;
      byOrigin.set(key,(byOrigin.get(key)||0)+t.tripsPerDay);
    }
    // scale dots
    const vals=[...byOrigin.values()];
    const max=Math.max(1, ...vals);
    for(const [key,v] of byOrigin.entries()){
      const [gx,gy]=key.split(",").map(Number);
      const dot=document.createElement("div");
      dot.className="heatDot";
      dot.style.left=(gx*cell+cell/2)+"px";
      dot.style.top =(gy*cell+cell/2)+"px";
      const alpha = 0.18 + 0.30*(v/max);
      dot.style.background=`rgba(239,68,68,${alpha.toFixed(2)})`;
      dot.style.width = (10 + 14*(v/max))+"px";
      dot.style.height= (10 + 14*(v/max))+"px";
      layer.appendChild(dot);
    }
  }

  // --- Demand Inspector: click a üè† to draw its OD lines to top destinations
  let inspectorLayer;
  function enableInspectorHandlers(){
    const map=$("#mapSquare");
    if(!inspectorLayer){
      inspectorLayer=document.createElement("div");
      inspectorLayer.className="odLine";
      map.appendChild(inspectorLayer);
    }
    updateEditingStatus();
  }
  function disableInspectorHandlers(){
    if(inspectorLayer) inspectorLayer.innerHTML="";
    updateEditingStatus();
  }
  function handleInspectorClick(e){
    // only react if clicked near a home
    const cell=parseInt($("#mapSquare").dataset.cell||"24",10);
    const rect=$("#mapSquare").getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const gx=Math.floor(mx/cell), gy=Math.floor(my/cell);
    // find nearest home within 1 cell
    let nearest=null, best=1e9;
    for(const h of homes){
      const d=Math.hypot(h.x-gx, h.y-gy);
      if(d<best){best=d; nearest=h;}
    }
    if(!nearest || best>1.1){ // not a home
      if(inspectorLayer) inspectorLayer.innerHTML="";
      return;
    }
    // draw lines for this home
    const list=od.filter(t=>t.ox===nearest.x && t.oy===nearest.y).sort((a,b)=>b.tripsPerDay-a.tripsPerDay).slice(0,6);
    drawODLines(list);
  }
  function drawODLines(list){
    if(!inspectorLayer) return;
    inspectorLayer.innerHTML="";
    const cell=parseInt($("#mapSquare").dataset.cell||"24",10);
    for(const t of list){
      const x1=t.ox*cell+cell/2, y1=t.oy*cell+cell/2;
      const x2=t.dx*cell+cell/2, y2=t.dy*cell+cell/2;
      const w = Math.max(1, Math.round(1 + t.tripsPerDay/6));
      const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
      svg.setAttribute("style","position:absolute; left:0; top:0; width:100%; height:100%;");
      const path = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      // Route orthogonally to better match the grid aesthetic
      const viaX = Math.abs(x2 - x1) > Math.abs(y2 - y1) ? x2 : x1;
      const viaY = viaX === x2 ? y1 : y2;
      const points = `${x1},${y1} ${viaX},${viaY} ${x2},${y2}`;
      path.setAttribute("points", points);
      path.setAttribute("fill", "none");
      path.setAttribute("stroke","rgba(220,38,38,0.6)");
      path.setAttribute("stroke-width",w);
      path.setAttribute("stroke-linecap","round");
      path.setAttribute("stroke-linejoin","round");
      svg.appendChild(path);
      inspectorLayer.appendChild(svg);
    }
  }

  // --- init & resize
  function rebuildAll(){
    sizeMap();
    generateCityState();
    renderCityDOM();
    buildOD();
    renderHeat();
  }

  function formatMoney(value){
    const sign=value<0?"-":"";
    const abs=Math.abs(value);
    return `${sign}$${abs.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2})}`;
  }

  function updateFinanceUI(){
    const cashEl=$("#cash");
    if(cashEl) cashEl.textContent=formatMoney(cash);
    const money=$("#money");
    if(money){
      const net=revenueToday-expensesToday;
      money.textContent=`${formatMoney(revenueToday)} ‚Äì ${formatMoney(expensesToday)} = ${formatMoney(net)}`;
    }
  }

  function formatTime(minute){
    const h=Math.floor(minute/60)%24;
    const m=minute%60;
    return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}`;
  }

  function serviceStatus(){
    let base;
    if(simMinute < SERVICE_START) base="Before service";
    else if(simMinute >= SERVICE_END) base="After service";
    else base="In service";
    if(!simRunning && simMinute>=SERVICE_START && simMinute<SERVICE_END) base+=" (paused)";
    return base;
  }

  function updateStatusBar(){
    const dayText = (window.TS?.dayText) || `Day ${simDay}`;
    const timeText = (window.TS?.timeText) || formatTime(simMinute);
    const serviceText = (window.TS?.serviceText) || serviceStatus();

    // Update day display in header
    const dayDisplayEl = document.getElementById("dayDisplay");
    if(dayDisplayEl){
      dayDisplayEl.textContent = dayText;
    }

    // Update status bar with time and service status
    const statusBarEl = document.getElementById("statusBar");
    if(statusBarEl){
      statusBarEl.textContent = `${timeText} ‚Äî ${serviceText}`;
    }
  }

  function updateClockLabel(){
    window.TS = window.TS || {};
    window.TS.dayText = `Day ${simDay}`;
    window.TS.timeText = formatTime(simMinute);
    window.TS.serviceText = serviceStatus();
    window.TS.clockMins = simMinute;
    updateStatusBar();
  }

  function resetDailyTallies(){
    ridersToday=0;
    revenueToday=0;
    expensesToday=0;
    updateFinanceUI();
  }

  function updatePlayButton(){
    const btn=$("#play");
    if(btn){ btn.textContent=simRunning?"‚è∏ Pause":"‚ñ∂ Play"; }
  }

  function updateSpeedButtons(){
    $$(".spd").forEach(btn=>{
      const mult=parseInt(btn.dataset.x||"1",10);
      if(mult===simSpeed) btn.classList.add("active");
      else btn.classList.remove("active");
    });
  }

  function stopSimTimer(){
    if(simTimer){ clearInterval(simTimer); simTimer=null; }
  }

  function setSimRunning(next){
    if(simRunning===next) return;
    simRunning=next;
    window.TS = window.TS || {};
    window.TS.paused = !simRunning;
    updatePlayButton();
    updateClockLabel();
    if(simRunning){
      stopSimTimer();
      simTimer=setInterval(()=>advanceSim(simSpeed), 400);
    }else{
      stopSimTimer();
    }
    const route=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(route||null);
  }

  function setSpeed(mult){
    simSpeed=mult;
    updateSpeedButtons();
  }

  function stepMinute(){
    const inService = simMinute>=SERVICE_START && simMinute<SERVICE_END;
    const currentHour=Math.floor(simMinute/60);
    const dtHours=1/60;
    let boardingsThisMinute=0;
    if(inService){
      for(const route of routes){
        if(route.lastLiveHour!==currentHour){
          route.lastLiveHour=currentHour;
          route.liveRidersThisHour=0;
        }
        if(route.riderBank==null) route.riderBank=0;
        const projected=Math.max(0, route.projectedHr||0);
        if(projected>0){
          route.riderBank += projected * dtHours;
          const newBoardings=Math.floor(route.riderBank);
          if(newBoardings>0){
            route.riderBank -= newBoardings;
            route.liveRidersThisHour = (route.liveRidersThisHour||0) + newBoardings;
            boardingsThisMinute += newBoardings;
            if(!route.firstRidersToastShown && route.liveRidersThisHour >= 1){
              showToast('üëè First riders!', 'Your service is picking up.');
              route.firstRidersToastShown=true;
            }
          }
        }else{
          route.riderBank=0;
          route.liveRidersThisHour=0;
        }
      }
    }else{
      for(const route of routes){
        if(route.lastLiveHour!==currentHour){
          route.lastLiveHour=currentHour;
        }
        route.liveRidersThisHour=0;
        route.riderBank=0;
      }
    }

    const liveTotal = routes.reduce((sum,r)=>sum + (r.liveRidersThisHour||0),0);
    window.TS = window.TS || {};
    window.TS.liveRidersPerHour = liveTotal;

    const revenue = boardingsThisMinute * fare;
    const expenses = inService ? (lastVehiclesUsed * VEHICLE_COST_PER_HOUR)/60 : 0;
    ridersToday += boardingsThisMinute;
    revenueToday = Math.round((revenueToday + revenue)*100)/100;
    expensesToday = Math.round((expensesToday + expenses)*100)/100;
    cash = Math.round((cash + revenue - expenses)*100)/100;

    simMinute++;
    if(!coachDayTipTriggered && routes.length){
      coachDayTipTriggered=true;
      setTimeout(()=>{ for(const route of routes){ analyzeRoute(route); } }, 0);
    }
    if(simMinute>=MINUTES_PER_DAY){
      simMinute=0;
      simDay++;
      resetDailyTallies();
      for(const route of routes){
        route.liveRidersThisHour=0;
        route.riderBank=0;
        route.lastLiveHour=undefined;
      }
    }
  }

  function advanceSim(minutes){
    for(let i=0;i<minutes;i++){
      stepMinute();
    }
    updateClockLabel();
    updateFinanceUI();
    const route=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(route||null);
  }

  function resetSimulationState(){
    stopSimTimer();
    simRunning=false;
    simDay=1;
    simMinute=SERVICE_START;
    cash=BASE_CASH;
    fare=DEFAULT_FARE;
    simSpeed=1;
    lastRidershipHr=0;
    lastVehiclesUsed=0;
    window.TS = window.TS || {};
    window.TS.paused = true;
    window.TS.liveRidersPerHour = 0;
    resetDailyTallies();
    updateFareDisplay();
    updatePlayButton();
    updateSpeedButtons();
    updateClockLabel();
    seenStatusBanners.clear();
    coachDayTipTriggered=false;
    for(const route of routes){
      route.riderBank=0;
      route.liveRidersThisHour=0;
      route.lastLiveHour=undefined;
      route.connectionToastShown=false;
      route.suggestedVehicleToast=false;
      route.firstRidersToastShown=false;
    }
    const route=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(route||null);
  }

  function jumpToServiceStart(){
    setSimRunning(false);
    if(simMinute >= SERVICE_START){
      simDay++;
      resetDailyTallies();
    }
    simMinute=SERVICE_START;
    updateClockLabel();
    updateFinanceUI();
    const route=editingRouteId ? routes.find(r=>r.id===editingRouteId) : null;
    updateRiderNumbersUI(route||null);
  }

  function updateFareDisplay(){
    const fareLabel=$("#fare");
    if(fareLabel) fareLabel.textContent=`$${fare.toFixed(2)}`;
  }

  function setFare(value){
    const clamped=Math.min(FARE_MAX, Math.max(FARE_MIN, Math.round(value*100)/100));
    fare=clamped;
    updateFareDisplay();
    updateRouteStats();
    const r=editingRouteId ? routes.find(x=>x.id===editingRouteId) : null;
    if(r){
      updateRouteDetails();
      analyzeRoute(r);
    }else{
      for(const route of routes){ analyzeRoute(route); }
    }
  }

  function init(){
    rebuildAll();
    resetSimulationState();
    const coachEl=$("#coach");
    const helpMask=$("#helpMask");
    const closeHelp=$("#closeHelp");
    const mapEl=$("#mapSquare");
    const addRouteBtn=$("#addRoute");

    coachEl && (coachEl.textContent = "Click [+ Add Route] then place stops near üè† homes and üõçÔ∏è destinations. Watch your riders grow!");

    if(closeHelp && helpMask){ closeHelp.onclick=()=>{ helpMask.style.display="none"; }; }

    window.addEventListener("resize",()=>{
      sizeMap();
      layoutTiles();
      drawCatchmentsForRoute(routes.find(r=>r.id===editingRouteId));
    });

    if(mapEl){
      mapEl.addEventListener("click", mapClickRouter);
      mapEl.addEventListener("mouseleave",()=>{ tipEl && (tipEl.style.display="none"); });
    }
    if(addRouteBtn){
      addRouteBtn.addEventListener("click", ()=>{
        const route=makeRoute();
        updateEditingStatus();
        drawCatchmentsForRoute(route);
        coachEl && (coachEl.textContent="Great! Now click the map to place stops. Connect homes üè† to destinations üõçÔ∏è!");
      });
    }

    $("#play").addEventListener("click", ()=>{ setSimRunning(!simRunning); });
    $("#newmap").addEventListener("click", ()=>{
      window.hasShownWinCelebration = false;
      goalRiders = 5000;
      setSimRunning(false);
      resetRoutes();
      rebuildAll();
      resetSimulationState();
      updateStatusBar();
      coachEl && (coachEl.textContent = "Click [+ Add Route] then place stops near üè† homes and üõçÔ∏è destinations. Watch your riders grow!");
      helpMask && (helpMask.style.display="none");
    });
    $("#reset").addEventListener("click", ()=>{
      window.hasShownWinCelebration = false;
      goalRiders = 5000;
      setSimRunning(false);
      resetRoutes();
      rebuildAll();
      resetSimulationState();
      updateStatusBar();
      coachEl && (coachEl.textContent = "Click [+ Add Route] then place stops near üè† homes and üõçÔ∏è destinations. Watch your riders grow!");
      helpMask && (helpMask.style.display="none");
    });

    window.addEventListener("keydown",(e)=>{
      const activeEl=document.activeElement;
      if(activeEl && (activeEl.tagName==='INPUT' || activeEl.tagName==='TEXTAREA' || activeEl.isContentEditable)) return;
      if(e.ctrlKey || e.metaKey || e.altKey) return;
      if(e.key.toLowerCase()==="n"){ makeRoute(); coachEl && (coachEl.textContent="Great! Now click the map to place stops. Connect homes üè† to destinations üõçÔ∏è!"); }
      else if(e.key==="Escape"){ editingRouteId=null; renderRoutesPanel(); updateRouteDetails(); updateEditingStatus(); clearHalos(); updateRiderNumbersUI(null); tipEl && (tipEl.style.display="none"); }
    });

    updateStatusBar();
  }

  window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
